<h1>About</h1>
<p>課程名稱: 協同產品設計實習 - Collaborative Product Design Practice</p>
<p>學員作業網站: <a class="Link--inTextBlock" href="https://mdecd2025.github.io/hw-41223230/">https://mdecd2025.github.io/hw-41223230/</a></p>
<p>學員作業倉儲: https://github.com/mdecd2025/hw-41223230</p>
<hr/>
<p>課程代號: cd2025</p>
<p>Teams 線上教學:</p>
<p style="padding-left: 30px;">以 "學號@nfu.edu.tw" 登入<span> </span><a href="https://login.microsoftonline.com/">https://login.microsoftonline.com/</a><span> </span>Office 365</p>
<p style="padding-left: 30px;">Teams 團隊代碼: <span>p5z4eku</span></p>
<hr/>
<p>課程評分:</p>
<p style="padding-left: 30px;">Homework (30%) - 每週至少提交兩次與課程進度有關的內容, 完成後填回自評表單</p>
<p style="padding-left: 30px;">Exam (40%) - 建立包含操作流程影片、心得以及提供檔案下載的網頁後填回自評表單</p>
<p style="padding-left: 30px;">Final Report (30%) - 利用網頁內容進行簡報並提交 pdf 格式書面報告, 完成後填回自評表單</p>
<h2>repo</h2>
<h1>Tasks</h1>
<h2>task1</h2>
<p>將上學期舊版的python 311 更改為python 313，以利之後使用<span>新版的 SciTE, Portablegit, PUTTY, ShareX, Wink 以及原有的 tmp 及 home_ipv6, 以另存新的</span><span> start.bat</span><span> </span><span>啟動</span></p>
<p><span><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/X7X6ZT_ccvA" width="560"></iframe></span></p>
<h3>list</h3>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">from browser import html, document, ajax  # 從 Brython 的 browser 模組匯入 html、document 和 ajax，方便操作 DOM 和發送請求

url = "https://mde.tw/list/2b.txt"  # 要讀取的文字檔網址（學員清單）

# 定義當 AJAX 請求完成時要執行的函式
def on_complete(req):
    if req.status == 200:  # 如果請求成功（狀態碼 200）
        data = req.text.splitlines()  # 取得文字內容並按行分割成清單
        all_stud = data[1:]  # 去除第一行標題，只保留學生資料

        # 建立一個無序清單 (UL) 元素
        stud_list = html.UL()

        # 逐行處理每位學生的資料
        for stud in all_stud:
            fields = stud.split()  # 假設每行資料用空白分隔，將其分割成清單
            if len(fields) &gt;= 2:  # 確保至少有兩個欄位（學號和帳號）
                stud_id, account = fields[:2]  # 取得學號與帳號
                link = f"https://github.com/mde2025/hw-{stud_id}"  # 組合 GitHub 作業連結

                # 創建一個清單項目 (LI)，包含帳號和超連結
                stud_list &lt;= html.LI([
                    f"{account} - ",  # 顯示帳號
                    html.A(link, href=link, target="_blank")  # 超連結指向 GitHub 作業頁面，另開新視窗
                ])

        # 將總人數與名單插入至網頁指定區塊中
        document["brython_div1"] &lt;= html.P(f"總共有 {len(all_stud)} 名學員")  # 顯示總人數
        document["brython_div1"] &lt;= stud_list  # 顯示整個清單

    else:
        # 若請求失敗，顯示錯誤訊息
        document["brython_div1"] &lt;= html.P("無法取得資料")

# 發送 AJAX 請求，並設定完成後執行的函式
ajax.get(url, oncomplete=on_complete)
</pre>
<p></p>
<p>執行名單(64位學員)</p>
<div id="brython_div1">
<ul>
<li>a40923137 -<span> </span><a href="https://github.com/mde2025/hw-40923137" target="_blank">https://github.com/mde2025/hw-40923137</a></li>
<li>41023114 -<span> </span><a href="https://github.com/mde2025/hw-41023114" target="_blank">https://github.com/mde2025/hw-41023114</a></li>
<li>c-ching -<span> </span><a href="https://github.com/mde2025/hw-41023205" target="_blank">https://github.com/mde2025/hw-41023205</a></li>
<li>tseYU000 -<span> </span><a href="https://github.com/mde2025/hw-41023206" target="_blank">https://github.com/mde2025/hw-41023206</a></li>
<li>junpig10 -<span> </span><a href="https://github.com/mde2025/hw-41023210" target="_blank">https://github.com/mde2025/hw-41023210</a></li>
<li>41023213 -<span> </span><a href="https://github.com/mde2025/hw-41023213" target="_blank">https://github.com/mde2025/hw-41023213</a></li>
<li>41023215 -<span> </span><a href="https://github.com/mde2025/hw-41023215" target="_blank">https://github.com/mde2025/hw-41023215</a></li>
<li>41023216 -<span> </span><a href="https://github.com/mde2025/hw-41023216" target="_blank">https://github.com/mde2025/hw-41023216</a></li>
<li>snowfall-killer -<span> </span><a href="https://github.com/mde2025/hw-41023218" target="_blank">https://github.com/mde2025/hw-41023218</a></li>
<li>YUN4 -<span> </span><a href="https://github.com/mde2025/hw-41023232" target="_blank">https://github.com/mde2025/hw-41023232</a></li>
<li>www000123 -<span> </span><a href="https://github.com/mde2025/hw-41023237" target="_blank">https://github.com/mde2025/hw-41023237</a></li>
<li>41071202 -<span> </span><a href="https://github.com/mde2025/hw-41071202" target="_blank">https://github.com/mde2025/hw-41071202</a></li>
<li>41071203 -<span> </span><a href="https://github.com/mde2025/hw-41071203" target="_blank">https://github.com/mde2025/hw-41071203</a></li>
<li>41071204 -<span> </span><a href="https://github.com/mde2025/hw-41071204" target="_blank">https://github.com/mde2025/hw-41071204</a></li>
<li>41223201 -<span> </span><a href="https://github.com/mde2025/hw-41223201" target="_blank">https://github.com/mde2025/hw-41223201</a></li>
<li>41223202 -<span> </span><a href="https://github.com/mde2025/hw-41223202" target="_blank">https://github.com/mde2025/hw-41223202</a></li>
<li>41223203 -<span> </span><a href="https://github.com/mde2025/hw-41223203" target="_blank">https://github.com/mde2025/hw-41223203</a></li>
<li>41223205 -<span> </span><a href="https://github.com/mde2025/hw-41223205" target="_blank">https://github.com/mde2025/hw-41223205</a></li>
<li>41223206 -<span> </span><a href="https://github.com/mde2025/hw-41223206" target="_blank">https://github.com/mde2025/hw-41223206</a></li>
<li>emma0312 -<span> </span><a href="https://github.com/mde2025/hw-41223207" target="_blank">https://github.com/mde2025/hw-41223207</a></li>
<li>41223208-hw -<span> </span><a href="https://github.com/mde2025/hw-41223208" target="_blank">https://github.com/mde2025/hw-41223208</a></li>
<li>41223209 -<span> </span><a href="https://github.com/mde2025/hw-41223209" target="_blank">https://github.com/mde2025/hw-41223209</a></li>
<li>41223211 -<span> </span><a href="https://github.com/mde2025/hw-41223211" target="_blank">https://github.com/mde2025/hw-41223211</a></li>
<li>jjjay41223212 -<span> </span><a href="https://github.com/mde2025/hw-41223212" target="_blank">https://github.com/mde2025/hw-41223212</a></li>
<li>RAY41223215 -<span> </span><a href="https://github.com/mde2025/hw-41223215" target="_blank">https://github.com/mde2025/hw-41223215</a></li>
<li>41223216 -<span> </span><a href="https://github.com/mde2025/hw-41223216" target="_blank">https://github.com/mde2025/hw-41223216</a></li>
<li>41223217 -<span> </span><a href="https://github.com/mde2025/hw-41223217" target="_blank">https://github.com/mde2025/hw-41223217</a></li>
<li>41223218 -<span> </span><a href="https://github.com/mde2025/hw-41223218" target="_blank">https://github.com/mde2025/hw-41223218</a></li>
<li>41223219 -<span> </span><a href="https://github.com/mde2025/hw-41223219" target="_blank">https://github.com/mde2025/hw-41223219</a></li>
<li>ljg41223220 -<span> </span><a href="https://github.com/mde2025/hw-41223220" target="_blank">https://github.com/mde2025/hw-41223220</a></li>
<li>leeshaowei0716 -<span> </span><a href="https://github.com/mde2025/hw-41223221" target="_blank">https://github.com/mde2025/hw-41223221</a></li>
<li>41223222 -<span> </span><a href="https://github.com/mde2025/hw-41223222" target="_blank">https://github.com/mde2025/hw-41223222</a></li>
<li>linryan23 -<span> </span><a href="https://github.com/mde2025/hw-41223223" target="_blank">https://github.com/mde2025/hw-41223223</a></li>
<li>41223224 -<span> </span><a href="https://github.com/mde2025/hw-41223224" target="_blank">https://github.com/mde2025/hw-41223224</a></li>
<li>41223225 -<span> </span><a href="https://github.com/mde2025/hw-41223225" target="_blank">https://github.com/mde2025/hw-41223225</a></li>
<li>41223226-0 -<span> </span><a href="https://github.com/mde2025/hw-41223226" target="_blank">https://github.com/mde2025/hw-41223226</a></li>
<li>41223227 -<span> </span><a href="https://github.com/mde2025/hw-41223227" target="_blank">https://github.com/mde2025/hw-41223227</a></li>
<li>hyy41223228 -<span> </span><a href="https://github.com/mde2025/hw-41223228" target="_blank">https://github.com/mde2025/hw-41223228</a></li>
<li>41223229 -<span> </span><a href="https://github.com/mde2025/hw-41223229" target="_blank">https://github.com/mde2025/hw-41223229</a></li>
<li>41223230 -<span> </span><a href="https://github.com/mde2025/hw-41223230" target="_blank">https://github.com/mde2025/hw-41223230</a></li>
<li>41223231 -<span> </span><a href="https://github.com/mde2025/hw-41223231" target="_blank">https://github.com/mde2025/hw-41223231</a></li>
<li>41223232 -<span> </span><a href="https://github.com/mde2025/hw-41223232" target="_blank">https://github.com/mde2025/hw-41223232</a></li>
<li>41223233even -<span> </span><a href="https://github.com/mde2025/hw-41223233" target="_blank">https://github.com/mde2025/hw-41223233</a></li>
<li>41223234 -<span> </span><a href="https://github.com/mde2025/hw-41223234" target="_blank">https://github.com/mde2025/hw-41223234</a></li>
<li>41223235 -<span> </span><a href="https://github.com/mde2025/hw-41223235" target="_blank">https://github.com/mde2025/hw-41223235</a></li>
<li>41223236 -<span> </span><a href="https://github.com/mde2025/hw-41223236" target="_blank">https://github.com/mde2025/hw-41223236</a></li>
<li>Cloud41223237 -<span> </span><a href="https://github.com/mde2025/hw-41223237" target="_blank">https://github.com/mde2025/hw-41223237</a></li>
<li>WeihHuang -<span> </span><a href="https://github.com/mde2025/hw-41223239" target="_blank">https://github.com/mde2025/hw-41223239</a></li>
<li>ych0227 -<span> </span><a href="https://github.com/mde2025/hw-41223240" target="_blank">https://github.com/mde2025/hw-41223240</a></li>
<li>41223242 -<span> </span><a href="https://github.com/mde2025/hw-41223242" target="_blank">https://github.com/mde2025/hw-41223242</a></li>
<li>41223243 -<span> </span><a href="https://github.com/mde2025/hw-41223243" target="_blank">https://github.com/mde2025/hw-41223243</a></li>
<li>Liu41223244 -<span> </span><a href="https://github.com/mde2025/hw-41223244" target="_blank">https://github.com/mde2025/hw-41223244</a></li>
<li>41223245 -<span> </span><a href="https://github.com/mde2025/hw-41223245" target="_blank">https://github.com/mde2025/hw-41223245</a></li>
<li>41223246 -<span> </span><a href="https://github.com/mde2025/hw-41223246" target="_blank">https://github.com/mde2025/hw-41223246</a></li>
<li>CYC41223247 -<span> </span><a href="https://github.com/mde2025/hw-41223247" target="_blank">https://github.com/mde2025/hw-41223247</a></li>
<li>41223248 -<span> </span><a href="https://github.com/mde2025/hw-41223248" target="_blank">https://github.com/mde2025/hw-41223248</a></li>
<li>41223249 -<span> </span><a href="https://github.com/mde2025/hw-41223249" target="_blank">https://github.com/mde2025/hw-41223249</a></li>
<li>timluo123 -<span> </span><a href="https://github.com/mde2025/hw-41223250" target="_blank">https://github.com/mde2025/hw-41223250</a></li>
<li>41223251 -<span> </span><a href="https://github.com/mde2025/hw-41223251" target="_blank">https://github.com/mde2025/hw-41223251</a></li>
<li>supowen -<span> </span><a href="https://github.com/mde2025/hw-41223252" target="_blank">https://github.com/mde2025/hw-41223252</a></li>
<li>jacky93111 -<span> </span><a href="https://github.com/mde2025/hw-41223253" target="_blank">https://github.com/mde2025/hw-41223253</a></li>
<li>41271237 -<span> </span><a href="https://github.com/mde2025/hw-41271237" target="_blank">https://github.com/mde2025/hw-41271237</a></li>
</ul>
</div>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/5U3FO9RJmgY" width="560"></iframe></p>
<p></p>
<p></p>
<h2>task2</h2>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">from browser import html, document, ajax  # 從 Brython 的 browser 模組匯入 html、document 和 ajax，用來操作網頁和發送請求

url = "https://mde.tw/list/2b.txt"  # 存放學生清單的純文字檔案網址

# G7 組員的學號集合，用 set 儲存，方便快速查詢是否為組員
g7_members = {"41023114", "41223218", "41223230", "41223247", "41223250", "41223240"}

# 定義當 AJAX 請求完成後要執行的函式
def on_complete(req):
    if req.status == 200:  # 如果伺服器回應狀態碼是 200（表示成功）
        data = req.text.splitlines()  # 將收到的純文字內容按行分割成列表
        all_stud = data[1:]  # 跳過第一行標題，取得所有學生資料

        # 建立一個無序清單 (UL) HTML 元素，用來放組員資料
        stud_list = html.UL()

        # 遍歷每一筆學生資料
        for stud in all_stud:
            fields = stud.split()  # 將每一行用空白切割，預期會得到 [學號, 帳號]
            if len(fields) &gt;= 2:  # 確保至少有學號和帳號兩欄
                stud_id, account = fields[:2]  # 取得學號和帳號

                # 如果這位學生是 G7 組員
                if stud_id in g7_members:
                    link = f"https://mdecd2025.github.io/hw-{stud_id}"  # 組合作業連結（對應 GitHub Pages）
                    
                    # 建立一個清單項目 (LI)，顯示帳號和超連結
                    stud_list &lt;= html.LI([
                        f"{account} - ",  # 顯示帳號
                        html.A(link, href=link, target="_blank")  # 加入一個可點擊的超連結，另開新分頁
                    ])

        # 把資訊插入到 HTML 中 id 為 brython_div1 的區塊
        document["brython_div1"] &lt;= html.P(f"G7 組員 ({len(g7_members)} 名)：")  # 顯示組員總數
        document["brython_div1"] &lt;= stud_list  # 顯示組員清單

    else:
        # 如果 AJAX 請求失敗（非 200 回應），顯示錯誤訊息
        document["brython_div1"] &lt;= html.P("無法取得資料")

# 使用 ajax.get 送出 GET 請求，完成後呼叫 on_complete 函式
ajax.get(url, oncomplete=on_complete)
</pre>
<p><a href="https://mdecd2025.github.io/hw-41223230/content/Brython.html?src=https://gist.githubusercontent.com/41223230/08a46cfd39bc94e2db5e3f6fd4def3da/raw/ad282570926b80d4247b77ba5c9b50fc0d6f6e10/g7*list">G7執行結果</a></p>
<p>小組成員名單</p>
<ul>
<li>41023114 -<span> </span><a href="https://mdecd2025.github.io/hw-41023114" target="_blank">https://mdecd2025.github.io/hw-41023114</a></li>
<li>41223218 -<span> </span><a href="https://mdecd2025.github.io/hw-41223218" target="_blank">https://mdecd2025.github.io/hw-41223218</a></li>
<li>41223230 -<span> </span><a href="https://mdecd2025.github.io/hw-41223230" target="_blank">https://mdecd2025.github.io/hw-41223230</a></li>
<li>ych0227 -<span> </span><a href="https://mdecd2025.github.io/hw-41223240" target="_blank">https://mdecd2025.github.io/hw-41223240</a></li>
<li>CYC41223247 -<span> </span><a href="https://mdecd2025.github.io/hw-41223247" target="_blank">https://mdecd2025.github.io/hw-41223247</a></li>
<li>timluo123 -<span> </span><a href="https://mdecd2025.github.io/hw-41223250" target="_blank">https://mdecd2025.github.io/hw-41223250</a></li>
</ul>
<p></p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/2pGRGViRHXI" width="560"></iframe></p>
<h2>task3</h2>
<p>2025/06/19 11:09 近端測試更新成功</p>
<p>過程影片</p><h2>task4</h2>
<p><a href="/downloads/base slvs.zip">base slvs.zip</a></p>
<p><a href="/downloads/base stl.zip">base stl.zip</a></p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/JLAK_XxcROc" width="560"></iframe></p>
<p></p>
<p><a href="/downloads/link_1 slvs.zip">link_1 slvs.zip</a></p>
<p><a href="/downloads/link_1 stl.zip">link_1 stl.zip</a></p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/Ts7ZFcCXKNk" width="560"></iframe></p>
<p></p>
<p><a href="/downloads/link_2 slvs.zip">link_2 slvs.zip</a></p>
<p><a href="/downloads/link_2 stl.zip">link_2 stl.zip</a></p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/tjHnqTaKbTE" width="560"></iframe></p>
<p></p>
<p><a href="/downloads/link_3 slvs.zip">link_3 slvs.zip</a></p>
<p><a href="/downloads/link_3 stl.zip">link_3 stl.zip</a></p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/ypFlndK7_kQ" width="560"></iframe></p>
<p></p>
<p><a href="/downloads/shaft_1 slvs.zip">shaft_1 slvs.zip</a></p>
<p><a href="/downloads/shaft_1 stl.zip">shaft_1 stl.zip</a></p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/6WI1kWlBBtU" width="560"></iframe></p>
<p></p>
<p><a href="/downloads/shaft_2 slvs.zip">shaft_2 slvs.zip</a></p>
<p><a href="/downloads/shaft_2 stl.zip">shaft_2 stl.zip</a></p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/paWNpYCaGks" width="560"></iframe></p>
<p></p>
<p><a href="/downloads/fourbar design.zip">fourbar design.zip</a></p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/bdlbFYSnWEc" width="560"></iframe></p>
<p></p>
<p><a href="/downloads/fourbar_assemble.zip">fourbar_assemble.zip</a></p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/_vLZ-WDcLAA" width="560"></iframe></p>
<h2>task5</h2>
<p><a href="/downloads/ball.7z">ball.7z</a></p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/2GvSd-wNujk" width="560"></iframe></p>
<p></p>
<p><a href="/downloads/base plate.7z">base plate.7z</a></p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/yJy7jEkn-CQ" width="560"></iframe></p>
<p></p>
<p><a href="/downloads/connected board.7z">connected board.7z</a></p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/rWlYSqvP8bg" width="560"></iframe></p>
<p></p>
<p><a href="/downloads/press board.7z">press board.7z</a></p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/6p5vr5nA5Vw" width="560"></iframe></p>
<p></p>
<p><a href="/downloads/shaft.7z">shaft.7z</a></p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/HTVPH48jvZY" width="560"></iframe></p>
<p></p>
<p><a href="/downloads/shaft1.7z">shaft1.7z</a></p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/wqvJcrwsViU" width="560"></iframe></p>
<p></p>
<p><a href="/downloads/shaft2.7z">shaft2.7z</a></p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/bH66Q43deCc" width="560"></iframe></p>
<p></p>
<p><a href="/downloads/shaft3.7z">shaft3.7z</a></p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/iii1WxkD5Hk" width="560"></iframe></p>
<p></p>
<p><a href="/downloads/shaft4.7z">shaft4.7z</a></p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/SOcDd300Djg" width="560"></iframe></p>
<p></p>
<p><a href="/downloads/shoot board.7z">shoot board.7z</a></p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/cCYTFHwxgBg" width="560"></iframe></p>
<p></p>
<p><a href="/downloads/shoot desing.7z">shoot design.7z</a></p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/cZgAqFCyGFA" width="560"></iframe></p>
<p></p>
<p><a href="/downloads/shooter assembly.zip">shooter assembly.zip</a></p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/bsL0zCX2XC8" width="560"></iframe></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<h2>task6</h2>
<h3>Tutorial1</h3>
<p><strong>Start webots</strong></p>
<p>1.啟動 Webots<br/>如果你還沒安裝 Webots，請先下載並安裝。安裝完成後，雙擊 Webots 的圖示啟動程式。第一次啟動時，可能會要求你選擇介面主題，選擇你喜歡的即可。</p>
<p>2.建立新專案<br/>點選「檔案」&gt;「新建」&gt;「新建專案目錄」，然後設定專案名稱為 my_first_simulation，並將世界檔案命名為 my_first_simulation.wbt。確保勾選「加入矩形競技場」選項，這樣就會自動建立一個包含地板和牆壁的簡單環境。</p>
<hr/>
<p>Create a New World</p>
<p>A World is a file containing information like where the objects are, what they look like, how they interact with each other, what is the color of the sky, and the definitions of gravity, friction, masses of the objects, etc. It defines the initial state of a simulation. The different objects are called Nodes and are organized hierarchically in a Scene Tree. Therefore, a node may contain sub-nodes. A world is stored in a file having the .wbt extension. The file format is derived from the VRML97 language, and is human readable. The world files must be stored directly in a directory called worlds.</p>
<p>一個<strong data-end="29" data-start="23">世界</strong>（World）是一個檔案，包含像是物體的位置、外觀、它們如何互動、天空的顏色、以及重力、摩擦力、物體質量等定義的資訊。它定義了模擬的初始狀態。不同的物體被稱為<strong data-end="114" data-start="108">節點</strong>（Nodes），並且以<strong data-end="132" data-start="125">場景樹</strong>（Scene Tree）的階層結構組織。因此，一個節點可能包含子節點。世界檔案儲存在具有<span> </span><code data-end="183" data-start="177">.wbt</code><span> </span>副檔名的檔案中。該檔案格式源自 VRML97 語言，並且是人類可讀的。世界檔案必須直接儲存在名為<span> </span><strong data-end="243" data-start="233">worlds</strong><span> </span>的資料夾中。</p>
<p>World – 世界，這是 Webots 的基本檔案類型，定義模擬的初始狀態。</p>
<p>File – 檔案，這裡指的是儲存世界資訊的檔案。</p>
<p>Objects – 物體，Webots 中的模擬物件。</p>
<p>Interact with – 互動，指的是物體之間的交互行為。</p>
<p>Color of the sky – 天空顏色，環境的一部分，通常會在背景設定中修改。</p>
<p>Gravity – 重力，物理參數之一。</p>
<p>Friction – 摩擦力，物理參數之一。</p>
<p>Masses – 質量，物理參數之一。</p>
<p>Nodes – 節點，Webots 中的基本物件，可以包含其他物件（子節點）。</p>
<p>Scene Tree – 場景樹，將節點按照層次結構組織的方式。</p>
<p>Sub-nodes – 子節點，節點下層的結構。</p>
<p>.wbt extension – .wbt 副檔名，Webots 世界檔的格式。</p>
<p>VRML97 – 一種三維虛擬現實建模語言，Webots 世界檔格式來源。</p>
<p>Human readable – 人類可讀，表示該檔案格式容易理解。</p>
<p></p>
<p>1.A is B that...</p>
<p>用來解釋 A 是 B 且 B 是什麼，這是一個常見的定義句型。</p>
<p>例句：</p>
<p>"A World is a file containing information like..."<br/>→ 「世界是一個包含以下資訊的檔案……」</p>
<p>2.like</p>
<p>用來舉例或列出類似的事物。</p>
<p>例句：</p>
<p>"...information like where the objects are, what they look like..."<br/>→ 「像是物體的位置、外觀等資訊」</p>
<p>3.and</p>
<p>用來連接詞語或句子中的多個項目。</p>
<p>例句：</p>
<p>"...the color of the sky, and the definitions of gravity, friction..."<br/>→ 「天空顏色，還有重力、摩擦力的定義」</p>
<p>4.Therefore</p>
<p>表示因果關係，通常用來引出結論。</p>
<p>例句：</p>
<p>"Therefore, a node may contain sub-nodes."<br/>→ 「因此，一個節點可能包含子節點。」</p>
<p>5.may</p>
<p>表示可能性，用來描述不確定的情況。</p>
<p>例句：</p>
<p>"A node may contain sub-nodes."<br/>→ 「一個節點可能會包含子節點。」</p>
<p>6.having</p>
<p>用來描述具有某種特徵的事物。</p>
<p>例句：</p>
<p>"A world is stored in a file having the .wbt extension."<br/>→ 「世界檔案是儲存在具有 .wbt 副檔名的檔案中。」</p>
<p>7.derived from</p>
<p>表示某事物來源於或基於某個東西。</p>
<p>例句：</p>
<p>"The file format is derived from the VRML97 language."<br/>→ 「檔案格式來源於 VRML97 語言。」</p>
<p>8.must be</p>
<p>用來強調必須做某事，是義務或要求。</p>
<p>例句：</p>
<p>"The world files must be stored directly in a directory called worlds."<br/>→ 「世界檔案必須直接儲存在名為 worlds 的資料夾中。」</p>
<p>主要是在講解場地</p>
<p>調整地板和牆壁大小<br/>在「場景樹」中選擇 RectangleArena，然後調整以下參數：</p>
<p>floorTileSize：改為 0.25 0.25，讓地板磚塊變小。</p>
<p>wallHeight：改為 0.05，讓牆壁變矮。</p>
<p>加入木箱<br/>點選「新增」按鈕，選擇 PROTO nodes (Webots Projects) / objects / factory / containers / WoodenBox (Solid)，在競技場中間會出現一個大箱子。選擇這個箱子，然後調整以下參數：</p>
<p>size：改為 0.1 0.1 0.1，讓箱子變小。</p>
<p>translation：改為 0 0 0.05，讓箱子稍微浮起。</p>
<p>接著，使用複製貼上（Ctrl+C 和 Ctrl+V）來新增兩個箱子，並將它們移動到競技場的不同位置，避免它們都集中在中間。</p>
<hr/>
<p><strong>Add an e-puck Robot</strong></p>
<p>The e-puck is a small robot having differential wheels, 10 LEDs, and several sensors including 8 DistanceSensors and a Camera. In this tutorial we are only interested in using its wheels.</p>
<p>e-puck 是一個小型機器人，擁有差速輪、10 顆 LED 燈和幾個感測器，包括 8 顆距離感測器和一個相機。在本教程中，我們只會關注它的輪子。我們會在接下來的教程中學習如何使用其他功能。</p>
<p>主要在講解e-puck機器人</p>
<p>加入 e-puck 機器人<br/>點選「新增」按鈕，選擇 PROTO nodes (Webots Projects) / robots / mobile / e-puck，這樣就會在競技場中加入一台 e-puck 機器人。</p>
<p>設定機器人控制程式<br/>在「場景樹」中選擇 e-puck，然後在 controller 欄位中輸入控制程式的名稱，例如 my_controller。這樣，當我們建立控制程式時，機器人就會使用它來控制行為。</p>
<p></p>
<p>e-puck - 小型機器人，這是 Webots 中的預設機器人之一。</p>
<p>differential wheels - 差速輪，兩個輪子的轉速差控制機器人的移動。</p>
<p>LEDs - 發光二極管，這裡指的是機器人上的燈。</p>
<p>DistanceSensors - 距離感測器，用來測量機器人與物體的距離。</p>
<p>PROTO node - 一種 Webots 節點，用來創建可重用的自定義物件。</p>
<p>Scene Tree - 場景樹，Webots 的節點組織結構。</p>
<p>real-time - 即時模擬模式。</p>
<p>mass - 質量，物體的物理屬性之一。</p>
<p>basicTimeStep - 基本時間步長，用於控制物理模擬的步伐。</p>
<p>reset - 重置，將模擬恢復到初始狀態。</p>
<p>simulation - 模擬，指在 Webots 中執行的虛擬環境。</p>
<p>apply a force - 施加力，用於操控物體的移動。</p>
<p>ctrl key - 控制鍵，用於進行某些操作的快捷鍵。</p>
<hr/>
<p data-pm-slice="1 1 []"><strong>Create a New Controller</strong></p>
<p>We will now program a simple controller that will just make the robot move forwards. A controller is a program that defines the behavior of a robot. Webots controllers can be written in the following programming languages: C, C++, Java, Python, MATLAB, etc. C, C++ and Java controllers need to be compiled before they can be run as robot controllers. Python and MATLAB controllers are interpreted languages so they will run without being compiled. In this tutorial, we are going to use C as a reference language but all the code snippets are also available in C++, Java, Python and MATLAB. Refer to the language chapter to setup a controller using a different programming language.</p>
<p>The controller field of a Robot node specifies which controller is currently associated to the robot. Note that the same controller can be used by several robots, but a robot can only use one controller at a time. Each controller is executed in a separate child process usually spawned by Webots. Because they are independent processes, controllers don't share the same address space, and may run on different processor cores.</p>
<p class="" data-end="273" data-start="42">控制器是一個程式，用來定義機器人的行為。Webots 控制器可以使用以下程式語言編寫：C、C++、Java、Python、MATLAB 等。C、C++ 和 Java 控制器需要編譯後才能作為機器人控制器運行，而 Python 和 MATLAB 控制器是直譯語言，因此不需要編譯就可以運行。在本教程中，我們將使用 C 作為參考語言，但所有的程式碼片段也會提供 C++、Java、Python 和 MATLAB 版本。若要使用其他程式語言設置控制器，請參閱語言章節。</p>
<p class="" data-end="443" data-start="275">機器人節點（Robot node）的控制器欄位指定了當前與機器人相關聯的控制器。請注意，同一個控制器可以被多個機器人使用，但每次只有一個機器人可以使用同一個控制器。每個控制器都是在一個單獨的子進程中執行，這些子進程通常是由 Webots 啟動的。由於它們是獨立的進程，控制器之間不共享相同的地址空間，並且可能會在不同的處理器核心上運行。</p>
<p>Controller - 控制器：定義機器人行為的程式。</p>
<p>Robot node - 機器人節點：Webots 中的一個節點，代表機器人本身。</p>
<p>Program - 程式：計算機執行的指令集，這裡指的是控制機器人行為的程式。</p>
<p>Compiled - 編譯：將程式碼轉換為機器能執行的格式。</p>
<p>Interpreted - 直譯：程式碼不需要編譯，而是由解釋器直接執行。</p>
<p>Language - 語言：指程式語言，這裡提到 C、C++、Java、Python 和 MATLAB。</p>
<p>Independent processes - 獨立進程：指每個控制器在不同的進程中運行，互不影響。</p>
<p>Address space - 地址空間：記憶體中用來儲存程序和資料的區域。</p>
<p>Processor cores - 處理器核心：處理器中的獨立運算單元。</p>
<p></p>
<p>1.We will now - 用來表示即將進行的動作，語氣較為強調未來行動。</p>
<p>例句：We will now program a simple controller.</p>
<p>2.that will - 用來表示目的或未來的動作。</p>
<p>例句：We will now program a simple controller that will just make the robot move forwards.</p>
<p>3.A controller is a program that - 定義和解釋某事物的結構，這裡是對「控制器」的解釋。</p>
<p>例句：A controller is a program that defines the behavior of a robot.</p>
<p>4.can be written in - 表示某事物可以以某種方式來做，這裡用於說明控制器的語言選擇。</p>
<p>例句：Webots controllers can be written in the following programming languages.</p>
<p>5.may run - 表示可能發生的狀況或行為。</p>
<p>例句：...and may run on different processor cores.</p>
<p>6.is executed in - 描述某事物的運行或執行方式。</p>
<p>例句：Each controller is executed in a separate child process usually spawned by Webots.</p>
<p>7.Refer to - 用來表示參考某資料或章節。</p>
<p>例句：Refer to the language chapter to setup a controller using a different programming language.</p>
<p></p>
<p>主要在講解建立控制程式<br/>在 Webots 中，控制程式是用來定義機器人行為的程式。你可以使用 Python、C、C++、Java 等語言來撰寫控制程式。這裡我們以 Python 為例。</p>
<p>撰寫簡單的前進程式<br/>在 Webots 的控制程式資料夾中，建立一個新的 Python 檔案，命名為 my_controller.py，並輸入以下程式碼：</p>
<p><strong></strong></p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">from controller import Robot, Motor
 
TIME_STEP = 64
MAX_SPEED = 6.28
 
robot = Robot()
 
leftMotor = robot.getMotor('left wheel motor')
rightMotor = robot.getMotor('right wheel motor')
 
leftMotor.setPosition(float('inf'))
rightMotor.setPosition(float('inf'))
 
leftMotor.setVelocity(0.1 * MAX_SPEED)
rightMotor.setVelocity(0.1 * MAX_SPEED)
 
while robot.step(TIME_STEP) != -1:
    pass
</pre>
<h3>Tutorial2</h3>
<p>在本教學中，我們將學習如何在環境中建立簡單的物件。第一步是建立一顆會與環境互動的球體。我們將探討與節點相關的多個概念：它們的意義、如何建立、如何關聯等。此外，我們還將了解如何設定物理屬性。</p>
<p>將介紹幾種類型的節點。它們的詳細定義可以在參考手冊中找到。擁有節點圖表將有助於理解節點之間的繼承關係。</p>
<hr/>
<p><strong>The Solid Node</strong></p>
<p>The Solid Node<br/>This subsection introduces the most important base node in Webots: the Solid node, from which many other nodes derive.</p>
<p>A Solid node represents a rigid body, that is a body in which deformation can be neglected. The distance between any two given points of a rigid body remains constant in time regardless of external forces exerted on it. For example a table, a robot finger phalanx or a wheel are rigid bodies. Soft bodies and articulated objects are not rigid bodies. For example, a rope, a tire, a sponge or an articulated robot arm are not rigid bodies. However, an articulated entity can be broken into several rigid bodies.</p>
<p>The physics engine of Webots is designed for simulating rigid bodies only. An important step, when designing a simulation, is to break up the various entities into separate rigid bodies.</p>
<p>To define a rigid body, you will have to create a Solid node. Inside this node you will set up different sub-nodes corresponding to the characteristics of the rigid body. The following figure depicts a rigid body and its sub-nodes. The graphical representation of the Solid node is defined by the Shape nodes populating its children list. The collision bounds are defined in its boundingObject field. The graphical representation and the collision shape are often but not necessarily identical. Finally, the physics field defines if the object belongs to the dynamical or to the static environment. All these sub-nodes are optional, but the physics field needs the boundingObject to be defined.</p>
<p>這一小節介紹了 Webots 中最重要的基礎節點：<strong>Solid 節點</strong>，許多其他節點都是從它衍生出來的。</p>
<p>Solid 節點代表一個剛體，也就是一種在模擬中可以忽略變形的物體。剛體中任意兩點之間的距離在時間中是保持不變的，即使有外力施加在上面也是如此。例如：桌子、機器人的指節、或是輪子，這些都是剛體。而軟體（soft bodies）或具有關節的物體則不屬於剛體，比如繩子、輪胎、海綿，或是關節式的機器人手臂就不是剛體。不過，一個有關節的物體可以拆解成數個剛體來處理。</p>
<p>Webots 的物理引擎專門用來<strong>模擬剛體</strong>。因此，在設計模擬時，一個重要的步驟就是把各個物件拆解成獨立的剛體。</p>
<p>若要定義一個剛體，你需要建立一個 Solid 節點。在這個節點中，你將設定一些子節點來描述這個剛體的特性。下圖展示了一個剛體及其子節點的結構：</p>
<p><strong>圖形外觀</strong>（Graphical representation） 是由放在 children 清單中的 Shape 節點 來定義的。</p>
<p><strong>碰撞邊界</strong>（Collision bounds） 則是由 boundingObject 欄位來設定。</p>
<p>通常圖形外觀與碰撞形狀是一樣的，但不一定非得相同。</p>
<p>最後，physics 欄位會決定這個物件是屬於<strong>動態物件</strong>還是<strong>靜態環境</strong>的一部分。</p>
<p>所有這些子節點都是可選的，但若要使用 physics 欄位，<strong>就必須定義</strong><span> </span>boundingObject。</p>
<p><img alt="" height="245" src="https://mdecd2025.github.io/hw-41023114/images/%E8%9E%A2%E5%B9%95%E6%93%B7%E5%8F%96%E7%95%AB%E9%9D%A2%202025-04-16%20220900.png" width="300"/></p>
<p>Solid node Solid 節點、剛體節點 Webots 中用來定義剛體的節點<br/>Rigid body 剛體 一種不會變形的物體<br/>Deformation 變形 通常是物體在受力後的形狀改變<br/>External force 外力 來自外部施加在物體上的力量<br/>Soft body 軟體 可以變形的物體<br/>Articulated object 關節式物體 有連接部位、可活動的物體<br/>Physics engine 物理引擎 模擬物理行為的程式模組<br/>Simulation 模擬 在電腦中模擬現實情境<br/>Sub-node 子節點 階層式結構中的下層節點<br/>Graphical representation 圖形表示 在 3D 視圖中可看到的外觀<br/>Collision bounds 碰撞邊界 用於物理計算的碰撞區域<br/>boundingObject 邊界物件欄位 定義碰撞邊界用的欄位<br/>children list 子節點清單 包含 Shape 等節點的集合<br/>Shape node 形狀節點 描述物體圖形的節點<br/>physics field 物理欄位 決定是否加入動力模擬<br/>dynamical/static environment 動態/靜態環境 是否會移動（物理互動）的物體</p>
<p></p>
<p>1.This subsection introduces...</p>
<p>用來開始段落、介紹某主題。</p>
<p>例句：This subsection introduces the most important base node in Webots.</p>
<p>翻譯：這一小節介紹了 Webots 中最重要的基礎節點。</p>
<p>2.A Solid node represents...</p>
<p>主詞 + 動詞 + 補語 → 用來定義或說明某事物的功能。</p>
<p>例句：A Solid node represents a rigid body.</p>
<p>翻譯：Solid 節點代表一個剛體。</p>
<p>3.can be broken into...</p>
<p>被動語態 + break into，表示可被分成...</p>
<p>例句：An articulated entity can be broken into several rigid bodies.</p>
<p>翻譯：關節式物體可以被分成多個剛體。</p>
<p>4.You will have to...</p>
<p>未來式 + have to，表示「你必須」。</p>
<p>例句：You will have to create a Solid node.</p>
<p>翻譯：你將需要建立一個 Solid 節點。</p>
<p>5....defined by...</p>
<p>表示由...定義、構成。</p>
<p>例句：The graphical representation is defined by the Shape nodes...</p>
<p>翻譯：圖形表示是由 Shape 節點定義的。</p>
<p>6....but not necessarily...</p>
<p>表示「但不一定是…」</p>
<p>例句：...are often but not necessarily identical.</p>
<p>翻譯：通常是相同的，但不一定。</p>
<p>7.All these sub-nodes are optional, but...</p>
<p>對比句型，用來表達例外或限制。</p>
<p>例句：All these sub-nodes are optional, but the physics field needs the boundingObject to be defined.</p>
<p>翻譯：這些子節點都是可選的，但若要使用 physics 欄位，就必須定義 boundingObject。</p>
<p></p>
<p>主要在講解</p>
<p>Solid 節點是 Webots 中最重要的基礎節點之一，代表一個剛體物件。它包含以下子節點：</p>
<p>Shape：定義物件的外觀。</p>
<p>boundingObject：定義物件的碰撞邊界。</p>
<p>physics：定義物件的物理屬性。</p>
<p>這些子節點是可選的，但如果要讓物件具有物理屬性，必須定義 boundingObject 和 physics。</p>
<hr/>
<p><strong>Create a Ball</strong></p>
<p>We will now add a ball to the simulation. That ball will be modeled as a rigid body as shown in this figure. A Sphere node will be used to define the geometry of our ball.</p>
<p>Hands-on #4: In the scene tree view, select the last node and press the Add button. In the dialog, open the Bases nodes section and select the Solid node. In the scene tree view, expand the Solid node and select its children field. Add a Shape node to it by using the Add button. Select the appearance field of the Shape node and use the Add button to add a PBRAppearance node.</p>
<p>1.Add a Sphere node as the geometry field of the newly created Shape node.<br/>2.Expand the PBRAppearance node and change its metalness field to 0 and its roughness field to 1.<br/>3.Add another Sphere node to the boundingObject field of the Solid.<br/>4.Finally add a Physics node to the physics field of the Solid.<br/>5.By modifying the translation field of the Solid node, place the ball in front of the robot (at {0.2, 0, 0.2} for example).<br/>6.Save the simulation.<br/>7.The result is depicted in this figure.</p>
<p>When the simulation is started, the ball hits the floor. You can move the ball by applying a force to it (ctrl + alt + left-click + drag). The contact points between the ball and the floor can be displayed as cyan lines by enabling the View / Optional Rendering / Show Contact Points menu item.</p>
<p class="" data-end="142" data-start="74">我們現在要在模擬中加入一顆球。這顆球將會被建模為一個<strong data-end="106" data-start="100">剛體</strong>，如下圖所示。我們將使用<span> </span><code data-end="127" data-start="119">Sphere</code><span> </span>節點來定義這顆球的幾何形狀。</p>
<p class="" data-end="388" data-start="144"><strong data-end="154" data-start="144">實作 #4：</strong><br data-end="157" data-start="154"/>在<span> </span><strong data-end="168" data-start="159">場景樹視圖</strong><span> </span>中，選取最後一個節點並按下<span> </span><strong data-end="189" data-start="183">新增</strong><span> </span>按鈕。在跳出的對話框中，展開<span> </span><strong data-end="220" data-start="205">Bases nodes</strong><span> </span>區段，然後選擇<span> </span><strong data-end="238" data-start="229">Solid</strong><span> </span>節點。<br data-end="245" data-start="242"/>在場景樹視圖中展開這個 Solid 節點，並選取它的<span> </span><code data-end="282" data-start="272">children</code><span> </span>欄位。接著，按下<span> </span><strong data-end="298" data-start="292">新增</strong><span> </span>按鈕加入一個<span> </span><strong data-end="315" data-start="306">Shape</strong><span> </span>節點。<br data-end="322" data-start="319"/>再選取剛加入的 Shape 節點的<span> </span><code data-end="352" data-start="340">appearance</code><span> </span>欄位，使用新增按鈕加入一個<span> </span><strong data-end="384" data-start="367">PBRAppearance</strong><span> </span>節點。</p>
<p class="" data-end="618" data-start="390">在 Shape 節點的<span> </span><code data-end="412" data-start="402">geometry</code><span> </span>欄位加入一個<span> </span><strong data-end="430" data-start="420">Sphere</strong><span> </span>節點，作為球的幾何外觀。<br data-end="446" data-start="443"/>展開 PBRAppearance 節點，將<span> </span><code data-end="479" data-start="468">metalness</code><span> </span>欄位改為<span> </span><strong data-end="490" data-start="485">0</strong>，<code data-end="502" data-start="491">roughness</code><span> </span>欄位改為<span> </span><strong data-end="513" data-start="508">1</strong>。<br data-end="517" data-start="514"/>在 Solid 節點的<span> </span><code data-end="545" data-start="529">boundingObject</code><span> </span>欄位中再加入一個<span> </span><strong data-end="565" data-start="555">Sphere</strong><span> </span>節點，用來定義碰撞邊界。<br data-end="581" data-start="578"/>最後，在<span> </span><code data-end="595" data-start="586">physics</code><span> </span>欄位加入一個<span> </span><strong data-end="614" data-start="603">Physics</strong><span> </span>節點。</p>
<p class="" data-end="697" data-start="620">透過修改 Solid 節點的<span> </span><code data-end="648" data-start="635">translation</code><span> </span>欄位，把球放在機器人前面的位置（例如設為<span> </span><code data-end="685" data-start="670">{0.2, 0, 0.2}</code>）。<br data-end="690" data-start="687"/>儲存這個模擬。</p>
<p class="" data-end="756" data-start="699">這是你在 Webots 中建立的第一個剛體。</p>
<p class="" data-end="905" data-start="758">當你開始模擬後，球會落到地板上。你可以透過施加力來移動這顆球（按住<span> </span><code data-end="811" data-start="792">Ctrl + Alt + 左鍵拖曳</code>）。<br data-end="816" data-start="813"/>若你想查看球與地面接觸的點，可以從功能表中點選：<strong data-end="891" data-start="840">View &gt; Optional Rendering &gt; Show Contact Points</strong>，就會以青綠色線條顯示出來。</p>
<p class="" data-end="905" data-start="758"></p>
<p class="" data-end="905" data-start="758">Ball 球體 模擬中新增的物件<br/>Rigid body 剛體 不會變形的物體，適合用於物理模擬<br/>Solid node Solid 節點 Webots 中用來定義剛體的節點<br/>Sphere node 球形節點 幾何形狀為球的節點<br/>Shape node 外觀節點 定義圖形外觀<br/>PBRAppearance node 實體外觀節點 用於設定金屬感、粗糙度等外觀屬性<br/>boundingObject 邊界物件欄位 用來定義物理碰撞用的區域<br/>Physics node 物理屬性節點 控制物體是否受重力、摩擦等影響<br/>translation 位移欄位 設定物體在空間中的位置<br/>metalness 金屬感 外觀參數，0 表示非金屬<br/>roughness 粗糙度 外觀參數，1 表示完全粗糙<br/>Apply a force 施加力量 移動物體的方式之一<br/>Contact point 接觸點 物體接觸地面時產生的物理點</p>
<p class="" data-end="905" data-start="758"></p>
<p>1.We will now add...</p>
<p>表示即將執行的操作。</p>
<p>例句：We will now add a ball to the simulation.</p>
<p>翻譯：我們現在要在模擬中加入一顆球。</p>
<p>2.That ball will be modeled as...</p>
<p>被動語態 + as，用於描述物件如何被建模。</p>
<p>例句：That ball will be modeled as a rigid body.</p>
<p>翻譯：這顆球會被建模成一個剛體。</p>
<p>3.Select the ... and press the Add button.</p>
<p>指令句型，常見於操作教學中。</p>
<p>例句：Select the last node and press the Add button.</p>
<p>翻譯：選取最後一個節點並按下新增按鈕。</p>
<p>4.Expand ... and change its ... field to ...</p>
<p>表示進入某節點並修改其欄位。</p>
<p>例句：Expand the PBRAppearance node and change its metalness field to 0.</p>
<p>翻譯：展開 PBRAppearance 節點，將 metalness 欄位設為 0。</p>
<p>5.The result is depicted in this figure.</p>
<p>被動語態，用於說明結果已被圖示。</p>
<p>例句：The result is depicted in this figure.</p>
<p>翻譯：結果如下圖所示。</p>
<p>6.You can move the ball by...</p>
<p>by + V-ing，表示透過某動作達成某目的。</p>
<p>例句：You can move the ball by applying a force to it.</p>
<p>翻譯：你可以透過施加力量來移動這顆球。</p>
<p>7.can be displayed by enabling...</p>
<p>被動語態 + by V-ing，表示可以透過某操作來達成。</p>
<p>例句：The contact points can be displayed by enabling the View menu...</p>
<p>翻譯：接觸點可以透過啟用 View 選單來顯示。</p>
<p></p>
<p>主要在講解如何建立球體</p>
<p><strong>1.新增 Solid 節點</strong><br/>在場景樹中選擇最後一個節點，點擊「新增」按鈕，選擇 Base nodes 中的 Solid 節點。</p>
<p><strong>2.新增 Shape 節點</strong><br/>展開 Solid 節點，選擇 children 欄位，點擊「新增」按鈕，選擇 Shape 節點。</p>
<p><strong>3.設定外觀</strong><br/>展開 Shape 節點，選擇 appearance 欄位，點擊「新增」按鈕，選擇 PBRAppearance 節點。將 metalness 設為 0，roughness 設為 1。</p>
<p><strong>4.設定幾何形狀</strong><br/>在 Shape 節點中，選擇 geometry 欄位，點擊「新增」按鈕，選擇 Sphere 節點。將 radius 設為 0.05，subdivision 設為 2。</p>
<p><strong>5.設定碰撞邊界</strong><br/>在 Solid 節點中，選擇 boundingObject 欄位，點擊「新增」按鈕，選擇 Sphere 節點。將 radius 設為 0.05，subdivision 設為 2。</p>
<p><strong>6.設定物理屬性</strong><br/>在 Solid 節點中，選擇 physics 欄位，點擊「新增」按鈕，選擇 Physics 節點。</p>
<p><strong>7.設定位置</strong><br/>在 Solid 節點中，選擇 translation 欄位，將其值設定為 {0.2, 0, 0.2}，將球體放置在機器人前方。</p>
<p><strong>8.儲存模擬</strong><br/>完成上述步驟後，儲存模擬檔案。</p>
<hr/>
<p><strong>Geometries</strong></p>
<p>To define the ball, we used the Sphere node in two different contexts: for the graphical representation (children) and to define the physical bounds (boundingObject). All Geometry nodes (such as the Sphere node) can be used in a graphical context. However, only a subset of them can be used in a physical context. The nodes chart diagram indicates which nodes are supported in each context.</p>
<p>We are now going to reduce the size of the Sphere and increase its graphical quality by increasing the number of triangles used to represent it.</p>
<p>Hands-on #5: For each Sphere node defining the ball, set its radius field to 0.05 and its subdivision field to 2. Refer to the Reference Manual to understand what the subdivision field stands for.</p>
<p>為了定義這顆球，我們在兩種不同的情境中使用了 Sphere（球體）節點：<br/>一是在圖形呈現（children）中，另一個則是用來定義物理邊界（boundingObject）。<br/>所有的幾何節點（像是 Sphere）都可以用在圖形呈現的情境中。<br/>然而，只有其中一部分的幾何節點可以用在物理模擬的情境中。<br/>你可以參考節點圖（nodes chart diagram），來確認每個節點在哪些情境中是被支援的。</p>
<p>接下來我們要縮小球的大小，並且提升圖形品質，方法是增加用來呈現球體的三角形數量。</p>
<p><strong>實作#5</strong></p>
<p>對每一個定義球體的 Sphere 節點，將：</p>
<p>radius 欄位設為 0.05，</p>
<p>subdivision 欄位設為 2。</p>
<p>若想進一步了解 subdivision 欄位的用途，可以參考官方的 Reference Manual（參考手冊）。</p>
<p></p>
<p>Geometry 幾何形狀 通常用來定義 3D 物件的外觀<br/>Sphere node 球體節點 幾何節點之一，用來建立球形物件<br/>Graphical representation 圖形呈現 指物體在 3D 視窗中看到的樣子<br/>BoundingObject 邊界物件 物體的碰撞範圍，為物理模擬用<br/>Physical context 物理情境 用於碰撞、重量、力等模擬計算<br/>Subset 子集合、部分 指從一大類中選出的某幾個<br/>Reduce 減少、降低 常用於尺寸、數量等<br/>Subdivision 分割數、細分數 決定幾何圖形的精細度（三角形數）<br/>Radius 半徑 控制球體的大小<br/>Reference Manual 參考手冊 官方說明文件</p>
<p></p>
<p>1.We used the Sphere node in two different contexts.</p>
<p>表示「我們在兩種不同情境下使用了 Sphere 節點」。</p>
<p>in [情境] context 是很實用的寫法！</p>
<p>例句翻譯：我們在兩種不同的情境中使用了 Sphere 節點。</p>
<p>2.All Geometry nodes can be used in a graphical context.</p>
<p>can be used：被動語態，表示「可以被使用」。</p>
<p>例句翻譯：所有幾何節點都可以用在圖形呈現中。</p>
<p>3.Only a subset of them can be used in a physical context.</p>
<p>only a subset of：只有其中的一部分。</p>
<p>例句翻譯：它們當中只有一部分可以用在物理情境中。</p>
<p>4.We are now going to reduce the size of the Sphere.</p>
<p>be going to + V：表示未來打算做某事。</p>
<p>例句翻譯：我們現在要來縮小球體的大小。</p>
<p>5.Increase its graphical quality by increasing the number of triangles.</p>
<p>by V-ing：藉由做某事來達成目的。</p>
<p>例句翻譯：透過增加三角形數量來提升圖形品質。</p>
<p>6.Set its radius field to 0.05 and its subdivision field to 2.</p>
<p>指令句常用語法，常見於操作說明中。</p>
<p>例句翻譯：將半徑欄位設為 0.05、細分欄位設為 2。</p>
<p></p>
<hr/>
<p><strong>DEF-USE Mechanism</strong></p>
<p>The DEF-USE mechanism allows to define a node in one place and to reuse that definition elsewhere in the scene tree. This is useful to avoid the duplication of identical nodes in world files. Moreover, it also allows users to modify several objects at the same time. Here is how it works: first a node is labeled with a DEF string. Then copies of this node can be reused elsewhere with the USE keyword. Only the fields of the DEF node can be edited, the fields of the USE inherit from the DEF node and cannot be changed. This mechanism is dependent on the order of the nodes in the world file. A DEF node should be defined before any corresponding USE node.</p>
<p>The two Sphere definitions that we have used earlier to define the ball, are redundant. We will now merge these two Spheres into only once using the DEF-USE mechanism.</p>
<p>Hands-on #6: Select the first Sphere node (the child of the Shape) in the scene tree view. The field editor of the scene tree view allows you to enter the DEF string.</p>
<p>Enter BALL_GEOMETRY in this field.<br/>Select the boundingObject field (containing the second Sphere node), and empty it by right clicking the field in the scene tree and choosing the Delete entry in the context menu that pops up.<br/>Then, select the boundingObject field and click on the Add button, and select the USE / BALL_GEOMETRY in the dialog box.<br/>The result is shown in this figure.<br/>Now, changing the radius field of the first Sphere node also modifies its boundingObject.</p>
<p>For convenience, the boundingObject field also accepts the Shape node (rather than the Sphere node directly). It would be also possible to use the same DEF-USE mechanism at the Shape level as shown in this figure. For now the greatest benefit is being able to also use this Shape directly for graphical purposes. Later this mechanism will turn out to be very useful for some sensors.</p>
<p>DEF-USE 機制可以讓你在場景樹中的某一處定義一個節點，然後在其他地方重複使用這個定義。<br/>這個機制的好處是可以避免在 world 檔中重複建立相同的節點，而且也能同時修改多個使用相同定義的物件。</p>
<p>它的運作方式如下：</p>
<p>1.先使用 DEF 關鍵字替一個節點取一個名稱。</p>
<p>2.接著，在其他位置可以使用 USE 關鍵字來引用這個節點。</p>
<p>3.<strong>只有被 DEF 定義的節點的欄位可以被修改</strong>，USE 的節點會繼承 DEF 的設定，不能獨立編輯。</p>
<p>4.這個機制依賴 world 檔中的節點順序：必須先定義 DEF 節點，才能在後面使用對應的 USE 節點。</p>
<p>我們之前為球體使用了兩個 Sphere 定義，這是重複的。<br/>現在我們要用 DEF-USE 機制，合併成一個 Sphere 節點來重複使用。</p>
<p>實作#6</p>
<ol data-end="739" data-start="507">
<li class="" data-end="548" data-start="507">
<p class="" data-end="548" data-start="510">在場景樹中，選取第一個<span> </span><code data-end="530" data-start="522">Sphere</code><span> </span>節點（<code data-end="541" data-start="534">Shape</code><span> </span>的子節點）。</p>
</li>
<li class="" data-end="593" data-start="549">
<p class="" data-end="593" data-start="552">在欄位編輯器中輸入<span> </span><code data-end="567" data-start="562">DEF</code><span> </span>名稱 →<span> </span><strong data-end="592" data-start="573"><code data-end="590" data-start="575">BALL_GEOMETRY</code></strong>。</p>
</li>
<li class="" data-end="669" data-start="594">
<p class="" data-end="642" data-start="597">選取<span> </span><code data-end="616" data-start="600">boundingObject</code><span> </span>欄位（裡面原本有第二個<span> </span><code data-end="637" data-start="629">Sphere</code><span> </span>節點）：</p>
<p class="" data-end="669" data-start="648">   右鍵 → 選擇「Delete」來清空內容。</p>
</li>
<li class="" data-end="739" data-start="670">
<p class="" data-end="739" data-start="673">再次選取<span> </span><code data-end="694" data-start="678">boundingObject</code><span> </span>欄位 → 按<span> </span><strong data-end="709" data-start="702">Add</strong><span> </span>→ 選擇<span> </span><strong>USE / BALL_GEOMETRY。</strong></p>
</li>
</ol>
<p class="" data-end="838" data-start="741">如圖所示，現在只用一個 Sphere 就能同時定義圖形外觀和碰撞邊界。<br data-end="779" data-start="776"/><strong data-end="838" data-start="779">當你改變第一個 Sphere 的<span> </span><code data-end="806" data-start="798">radius</code><span> </span>時，它的<span> </span><code data-end="828" data-start="812">boundingObject</code><span> </span>也會跟著改變。</strong></p>
<p class="" data-end="949" data-start="840">另外，為了方便起見，<code data-end="866" data-start="850">boundingObject</code><span> </span>欄位其實也可以接受整個<span> </span><code data-end="886" data-start="879">Shape</code><span> </span>節點（不只限於<span> </span><code data-end="903" data-start="895">Sphere</code>）。<br data-end="908" data-start="905"/>因此也可以將整個<span> </span><code data-end="924" data-start="917">Shape</code><span> </span>節點用<span> </span><code data-end="938" data-start="929">DEF-USE</code><span> </span>重複使用，如圖所示。</p>
<p class="" data-end="1022" data-start="951">目前這樣做最大的好處是可以直接把這個<span> </span><code data-end="977" data-start="970">Shape</code><span> </span>用來做圖形呈現，<br data-end="989" data-start="986"/>以後我們在設定感測器（sensor）時，也會發現這個機制非常實用。</p>
<p class="" data-end="1022" data-start="951"></p>
<p class="" data-end="1022" data-start="951">DEF-USE mechanism 定義與重複使用的機制 Webots 中節點重用的重要工具<br/>Scene tree 場景樹 所有節點階層結構的視覺呈現<br/>Node 節點 Webots 中的基本建構單元<br/>Field editor 欄位編輯器 可編輯節點屬性的地方<br/>BoundingObject 碰撞邊界物件欄位 定義物理碰撞區域<br/>Graphical representation 圖形呈現 物體在 3D 視圖中所呈現的外觀<br/>Context menu 快速選單、右鍵選單 使用者右鍵點擊時出現的功能選單<br/>Convenience 便利性、方便性 在說明某功能使用上較為方便時常見用詞<br/>Inherit 繼承 指 USE 會繼承 DEF 的屬性設定</p>
<p class="" data-end="1022" data-start="951"></p>
<p>1.The DEF-USE mechanism allows [動詞片語]</p>
<p>表示「這個機制可以讓你做…」</p>
<p>The DEF-USE mechanism allows to define a node…</p>
<p>DEF-USE 機制可以讓你定義節點…</p>
<p>2.Only the fields of the DEF node can be edited.</p>
<p>被動語態 + 限定詞 only，常見於規則說明。</p>
<p>Only the fields of the DEF node can be edited.</p>
<p>只有 DEF 節點的欄位可以被修改。</p>
<p>3.The fields of the USE inherit from the DEF node.</p>
<p>簡潔地表達繼承關係，用於物件導向、資料繼承等情境。</p>
<p>The fields of the USE inherit from the DEF node.</p>
<p>USE 的欄位會繼承 DEF 的設定。</p>
<p>4.A DEF node should be defined before any corresponding USE node.</p>
<p>should be + 過去分詞：表示應該要做某事的被動句型。</p>
<p>A DEF node should be defined before any corresponding USE node.</p>
<p>DEF 節點應該要在對應的 USE 節點之前定義好。</p>
<p>5.Now, changing the radius field... also modifies its boundingObject.</p>
<p>Now, + V-ing：現在做某事會產生什麼結果。</p>
<p>Now, changing the radius field also modifies its boundingObject.</p>
<p>現在，改變半徑也會同時改變碰撞邊界。</p>
<p></p>
<p>主要在講解DEF-USE機制</p>
<p class="" data-end="1650" data-start="1623">為了減少節點重複，我們可以使用 DEF-USE 機制。</p>
<ol data-end="1880" data-start="1652">
<li class="" data-end="1760" data-start="1652">
<p class="" data-end="1760" data-start="1655"><strong data-end="1668" data-start="1655">設定 DEF 標籤</strong><br data-end="1671" data-start="1668"/>在場景樹中，選擇<span> </span><code data-end="1690" data-start="1683">Shape</code><span> </span>節點，展開它，找到<span> </span><code data-end="1711" data-start="1701">geometry</code><span> </span>欄位，選擇<span> </span><code data-end="1726" data-start="1718">Sphere</code><span> </span>節點，將<span> </span><code data-end="1737" data-start="1732">DEF</code><span> </span>欄位設定為<span> </span><code data-end="1759" data-start="1744">BALL_GEOMETRY</code>。</p>
</li>
<li class="" data-end="1880" data-start="1762">
<p class="" data-end="1880" data-start="1765"><strong data-end="1778" data-start="1765">使用 USE 標籤</strong><br data-end="1781" data-start="1778"/>在場景樹中，選擇<span> </span><code data-end="1800" data-start="1793">Solid</code><span> </span>節點，展開它，找到<span> </span><code data-end="1827" data-start="1811">boundingObject</code><span> </span>欄位，右鍵點擊，選擇「刪除」。然後，點擊「新增」按鈕，選擇<span> </span><code data-end="1879" data-start="1858">USE / BALL_GEOMETRY</code>。</p>
</li>
</ol>
<p class="" data-end="1948" data-start="1882">這樣，當你修改<span> </span><code data-end="1905" data-start="1890">BALL_GEOMETRY</code><span> </span>的屬性時，所有使用<span> </span><code data-end="1937" data-start="1916">USE / BALL_GEOMETRY</code><span> </span>的節點都會同步更新。</p><h3>Tutorial3</h3>
<p>The aim of this tutorial is to familiarize yourself with some nodes related to the graphical rendering. Good looking simulations can be created very quickly when these nodes are used adequately. A good graphics quality does not only enhance the user's experience, it is also essential for simulations where robots perceive their environment (camera image processing, line following, etc.).</p>
<p>這個教學的目的是讓你熟悉一些跟圖形渲染相關的節點。只要善用這些節點，就能很快做出視覺效果不錯的模擬畫面。畫面品質好不只會讓使用者體驗更好，對於那些需要靠影像來感知環境的模擬（像是攝影機影像處理、循線等等）來說，也非常重要。</p>
<hr/>
<p><strong>Light</strong></p>
<p>Lights The lighting of a world is determined by Light nodes and the Background . There are three types of light nodes: the DirectionalLight, the PointLight and the SpotLight. A DirectionalLight simulates a light which is infinitely far (ex: the sun), a PointLight simulates light emitted from a single point (ex: a light bulb), and a SpotLight simulates a conical light (ex: a flashlight). This figure shows a comparison between them. Each type of light node can cast shadows.</p>
<p>一個場景的光線是由 Light 節點和背景來決定的。Light 節點有三種類型：DirectionalLight（方向光）、PointLight（點光源）和 SpotLight（聚光燈）。</p>
<p>DirectionalLight 模擬的是從無限遠處照射過來的光（例如：太陽）。</p>
<p>PointLight 則是從某個點發出來的光（例如：電燈泡）。</p>
<p>SpotLight 則是錐形照射的光（例如：手電筒）。</p>
<p> </p>
<p>lighting 照明、光線配置，指整個場景的光影效果。<br/>determined by 由...決定，常用於說明某件事的因素或來源。<br/>Light nodes 燈光節點，是 Webots 中用來產生光源的物件。<br/>Background 背景，這裡指模擬環境的背景會影響整體照明效果。<br/>DirectionalLight 方向光，模擬來自遠處（如太陽）的平行光。<br/>PointLight 點光源，模擬從一個點向四周發射的光（如燈泡）。<br/>SpotLight 聚光燈，模擬錐形範圍內的光（如手電筒）。<br/>simulate 模擬、模仿，是模擬軟體常見的術語。<br/>cast shadows 投影，意指該光源會產生陰影效果。<br/>Reference Manual 參考手冊，通常指官方文件或說明書。</p>
<p></p>
<p>1.The lighting of a world is determined by Light nodes and the Background.</p>
<p>句型結構：被動語態（is determined by）</p>
<p>主詞：The lighting of a world（這個世界的照明）</p>
<p>動詞：is determined（被決定）</p>
<p>介詞片語：by Light nodes and the Background（由光源節點和背景決定）</p>
<p>用來強調「誰」或「什麼」決定了照明效果，是科技文常見句型。</p>
<p>2.There are three types of light nodes: the DirectionalLight, the PointLight and the SpotLight.</p>
<p>句型結構：There are + 名詞（用來說明有某些東西存在）</p>
<p>適合用來介紹種類、列表或分類。</p>
<p>3.A DirectionalLight simulates a light which is infinitely far.</p>
<p>文法重點：</p>
<p>which is infinitely far 是形容詞子句，用來修飾「light」</p>
<p>infinitely 為副詞，修飾形容詞 far，表示「非常遠」。</p>
<p>常見的定義型句式，用來描述某個東西的作用或特性。</p>
<p>4.Each type of light node can cast shadows.</p>
<p>句型結構：助動詞 can + 原形動詞（cast）→ 表示能力</p>
<p>用來說明這些光源節點有什麼功能。</p>
<p>5.You can find their complete documentation in the Reference Manual.</p>
<p>句型結構：can + find（表達能力/可能）</p>
<p>是一種常見的指引說法，鼓勵讀者去查閱手冊。</p>
<hr/>
<p><strong>Modify the Appearance of the Walls</strong></p>
<p>Modify the Appearance of the Walls<br/>The aim of this subsection is to color the walls in blue.</p>
<p>The Appearance and PBRAppearance nodes of the Shape node determine the graphical appearance of the object. Among other things, these nodes are responsible for the color and texture of objects.</p>
<p>Prefer PBRAppearances for a better rendering as shown in the following comparison.</p>
<p>Hands-on #2: In the Shape node representing graphically the first wall, add a PBRAppearance node to the appearance field.</p>
<p>Set its baseColor field to blue using the color selector.<br/>Set its metalness field to 0 using the field editor.<br/>Finally, set its roughness field to 0.5 using the field editor.<br/>If the DEF-USE mechanism of the previous tutorial has been correctly implemented, all the walls should turn blue.</p>
<p>Add an Existing Appearance to the Ball<br/>A number of pre-defined PBRAppearance are provided in the Webots release.</p>
<p>Hands-on #3: Add a pre-defined PBRAppearance</p>
<p>Select the appearance field and remove the previously added node. To do this, either press the "delete" button on your keyboard or right-click on the field and select "delete" from the menu. The field should now say "appearance NULL" instead of "appearance PBRAppearance".<br/>Double-click on the field again, then navigate to PROTO nodes (Webots Projects), then appearances and select OldSteel (PBRAppearance).</p>
<p></p>
<p>修改牆壁的外觀<br/>這一小節的目標是把牆壁改成藍色的。</p>
<p>在 Webots 中，Shape 節點裡的 Appearance 跟 PBRAppearance 這兩個節點會決定物件的外觀。像是顏色、材質（紋理）等等都是靠它們設定的。</p>
<p>為了讓畫面更真實，建議你使用 PBRAppearance，下面這張圖就展示了兩者的差別。</p>
<p></p>
<p>實做 #2：讓第一面牆變藍色<br/>找到用來顯示第一面牆的 Shape 節點，在它的 appearance 欄位加上一個 PBRAppearance 節點。</p>
<p>把 baseColor（底色）設成藍色，可以用顏色選擇器來設。</p>
<p>把 metalness（金屬感）設成 0，用欄位編輯器改。</p>
<p>把 roughness（粗糙度）設成 0.5，也是一樣用欄位編輯器改。</p>
<p>如果你有按照前一個教學設定好 DEF-USE 機制，那麼只要改一面牆，其他牆也會一起變藍。</p>
<p>##給球體加上已經做好的外觀<br/>Webots 裡面其實有一堆預設好的 PBRAppearance，可以直接拿來用。</p>
<p>實做 #3：套用一個預設的 PBRAppearance<br/>先選到球體的 appearance 欄位，刪掉原本加的節點。可以按鍵盤上的 delete，或者右鍵點選「delete」。</p>
<p>成功刪除的話，欄位會從「appearance PBRAppearance」變成「appearance NULL」。</p>
<p>接著再雙擊這個欄位，然後依序點進：</p>
<p>PROTO nodes (Webots Projects) → appearances → 選 OldSteel (PBRAppearance)。</p>
<p></p>
<p><br/>Appearance / PBRAppearance 控制物件的外觀樣式，PBRAppearance 提供更真實的渲染效果。<br/>Shape node Webots 中用來表示物體形狀的節點。<br/>baseColor 物件的底色。<br/>metalness 金屬感，用數值表達材質像不像金屬（0 = 非金屬，1 = 金屬）。<br/>roughness 粗糙程度，數值越高越不光滑。<br/>field editor 欄位編輯器，用來改節點的屬性。<br/>color selector 顏色選擇器，點選後可選顏色。<br/>appearance NULL 表示目前沒有設定 appearance。<br/>PROTO node 預先定義好的節點，可以重複使用。<br/>DEF-USE 機制 Webots 中讓一個節點可以重複使用的機制。</p>
<p></p>
<p>1.The aim of this subsection is to...</p>
<p>結構：主詞 + be 動詞 + to V</p>
<p>用來說明某段教學的目的，很常見於技術文件。</p>
<p>2.Among other things, these nodes are responsible for...</p>
<p>表達「除了其他功能外，這些節點的責任是...」</p>
<p>be responsible for 表示「負責…」、「控制…」</p>
<p>3.Set its baseColor field to blue using the color selector.</p>
<p>這是一種常見的指令句，用動詞原形開頭（Set），常見於說明手冊。</p>
<p>using + 工具 → 表示用什麼工具去完成動作。</p>
<p>4.If the DEF-USE mechanism... has been correctly implemented...</p>
<p>現在完成式被動語態：has been + 過去分詞</p>
<p>表示某個設定是否已經正確完成。</p>
<p>5.Select the appearance field and remove...</p>
<p>這類句子都是指令式，直接用動詞原形（Select, Remove）開頭，常見於步驟教學。</p>
<hr/>
<p data-pm-slice="0 0 []"><strong>Add a Texture from Disk</strong></p>
<p>Add a Texture from Disk The aim of this subsection is to apply a locally available texture to the ball. A texture on a rolling object can help to appreciate its movement. Hands-on #4: add a locally available texture to the ball. Download the texture available here and save it to your disk. Remove the previously added node from the appearance field and add a PBRAppearance node instead. Add an ImageTexture node to the baseColorMap field of the PBRAppearance node. Add an item to the ImageTexture's url field using the Add button. Then set the value of the newly added url item using the "Select" button. Follow the path to the location where you saved the texture and select it. The texture URLs must be defined either relative to the worlds directory of your project directory or relative to the default project directory WEBOTS_HOME/projects/default/worlds. Open the red_brick_wall.jpg texture in an image viewer while you observe how it is mapped onto the Sphere node in Webots. Textures are mapped onto Geometry nodes according to predefined UV mapping functions described in the Reference Manual. A UV mapping function maps a 2D image representation to a 3D model.</p>
<p></p>
<p>這一小節的目的是把本機電腦上的材質圖貼到球體上。<br/>球體有材質圖的話，當它在滾動時，你會更容易看出它的動作。</p>
<p>實作 #4：給球體加上一張本地的材質貼圖<br/>先下載這裡提供的材質圖，然後把它存到你的電腦上。</p>
<p>到 appearance 欄位，把之前加的節點刪掉，改成加一個 PBRAppearance 節點。</p>
<p>在這個 PBRAppearance 裡的 baseColorMap 欄位，加一個 ImageTexture 節點。</p>
<p>點一下 ImageTexture 的 url 欄位，用「Add」按鈕新增一個項目。</p>
<p>新增完以後，按「Select」按鈕，選取你剛才下載的圖片。</p>
<p>找到你存放圖片的資料夾，選取那張圖片。</p>
<p>小提醒：這個圖片的網址（URL）一定要是相對於你的 world 資料夾，或者是相對於 Webots 的預設資料夾：WEBOTS_HOME/projects/default/worlds。</p>
<p>接著，你可以在圖像檢視器中打開這張 red_brick_wall.jpg 圖片，一邊觀察它是怎麼被貼到球體（Sphere node）上的。</p>
<p>貼圖是怎麼運作的？<br/>Webots 會根據預先定義好的 UV mapping 函數，把 2D 的圖片貼到 3D 物件上。</p>
<p>UV mapping 就是把一張平面圖片「攤平」貼到 3D 模型表面的技術，詳細的說明可以看參考手冊。</p>
<p></p>
<p><br/>texture 材質圖、貼圖，用來給物件表面加上圖案或細節。<br/>locally available 本機可用的，表示檔案已經存在於你的電腦中。<br/>apply 套用（某個設定、圖案等）。<br/>rolling object 滾動中的物體（如球）。<br/>ImageTexture Webots 中用來載入圖片貼圖的節點。<br/>url field 圖片的位置（網址或路徑），可以是相對路徑。<br/>baseColorMap 貼圖的位置，會貼在物件的底色上。<br/>relative to 相對於…（用於說明檔案路徑的定位）。<br/>UV mapping 把 2D 圖片對應到 3D 模型的技術。<br/>WEBOTS_HOME Webots 的安裝根目錄（系統預設資料夾）。</p>
<p></p>
<p>1.The aim of this subsection is to...</p>
<p>句型結構：主詞 + be + to V</p>
<p>用來說明這段內容的目標或任務。</p>
<p>2.can help to appreciate its movement</p>
<p>help to V 是常見結構，表示「幫助你能...」</p>
<p>appreciate 在這裡不是「感激」，而是「看得出來、欣賞」。</p>
<p>3.Follow the path to...</p>
<p>這是常見的操作指令句，叫使用者去找某個路徑或資料夾。</p>
<p>4.Textures are mapped onto...</p>
<p>被動語態：Textures are mapped（貼圖被套用到…上）</p>
<p>技術說明中常見的語態，用來解釋系統自動處理的事情。</p>
<p>5.described in the Reference Manual</p>
<p>過去分詞當形容詞使用，說明「被描述於參考手冊中」。</p>
<hr/>
<p><strong>Rendering Options</strong></p>
<p>Rendering Options Webots offers several rendering modes available in the View menu. Hands-on #5: View the simulation in wireframe mode by using the View / Wireframe Rendering menu item. Then restore the plain rendering mode: View / Plain Rendering. Others rendering features can be helpful: View Coordinates systems: View / Optional Rendering / Show Coordinates System ctrl-F1 View distance sensor rays: View / Optional Rendering / Show DistanceSensor Rays ctrl-F10</p>
<p></p>
<p>Webots 提供了幾種不同的渲染模式，你可以從 View（檢視）選單中切換。</p>
<p>實作 #5：切換線框模式<br/>到選單中點選：View / Wireframe Rendering，就可以切換成 線框模式（看起來像只有線條輪廓的畫面）。</p>
<p>想要恢復正常顯示，選擇：View / Plain Rendering。</p>
<p>除了這些，還有其他實用的渲染功能可以幫助你觀察模擬：</p>
<p>顯示座標系統：View / Optional Rendering / Show Coordinates System（快捷鍵：Ctrl + F1）</p>
<p>顯示距離感測器的光線：View / Optional Rendering / Show DistanceSensor Rays（快捷鍵：Ctrl + F10）</p>
<p></p>
<p>1.Webots offers several rendering modes...</p>
<p>offer + 受詞：提供...</p>
<p>用來介紹功能是很常見的句型。</p>
<p>2.Hands-on #5: View the simulation in wireframe mode...</p>
<p>指令句：直接用動詞原形（View）開頭，常見於教學手冊。</p>
<p>in wireframe mode：用介系詞 in 表示「以某種模式」。</p>
<p>3.Then restore the plain rendering mode...</p>
<p>restore：恢復，這裡用來指切換回預設顯示方式。</p>
<p>4.Others rendering features can be helpful:</p>
<p>正確寫法應該是 Other rendering features（語法上這是小錯誤，other 沒有 s）</p>
<p>can be helpful：可以很有幫助，常見於說明提示中。</p>
<p>5.Show Coordinates System ctrl-F1</p>
<p>命令 + 快捷鍵：這種格式在教學說明中很常見，用來告知操作與快捷鍵對應方式。</p><h1>Homework</h1>
<p>作業 (30%)</p>
<p>HW1 (5%): <span style="background-color: #ffff00;">建立由 Box 組成的平面四連桿機構 Webots 模擬場景</span></p>
<p style="padding-left: 30px;">part1:</p>
<p style="padding-left: 60px;">請各學員在 USB 隨身碟或個人電腦上完成 cd2025 課程所需的可攜系統配置:</p>
<p style="padding-left: 90px;">下載 <a href="http://229.cycu.org/portable_wcm2025.7z">portable_wcm2025.7z</a> (330MB, 解開壓縮後 1.4GB)</p>
<p style="padding-left: 90px;"><a href="http://229.cycu.org/Webots_2025a.7z">Webots_2025a.7z</a> (1.5 GB, 解開後約為 2.9GB, 可單獨運作)</p>
<p style="padding-left: 90px;"><a href="http://229.cycu.org/Webots_2025a_web.7z">Webots_2025a_web.7z</a> (171 MB, 解開壓縮後約為 1GB, 必須連網運作)</p>
<p style="padding-left: 90px;"><a href="http://229.cycu.org/Blender4.2.7z">Blender4.2.7z</a></p>
<p style="padding-left: 30px;">part2:</p>
<p style="padding-left: 60px;">請各學員完成可攜程式系統配置後, 利用 Webots R2025a 中寬度與高度都為 0.1m 的 box 物件建立一個簡單的平面四連桿機構模擬場景.</p>
<p style="padding-left: 60px;">base (基座) 長度 1m, link1 長度 0.4m, link2 長度 0.6m, link3 長度 0.9m, 各轉軸均為 HingeJoint, joint1 旋轉速度設定為 1radian/sec.</p>
<p style="padding-left: 30px;">part3:</p>
<p style="padding-left: 60px;">模擬場景啟動後, 按下 s 鍵機構開始作動, 按下 p 鍵後機構暫停.</p>
<p style="padding-left: 30px;">參考資料:</p>
<p style="padding-left: 60px;"><a href="/downloads/cd2025_hw1_demo.7z">cd2025_hw1_demo.7z</a></p>
<p>HW2 (5%): <span style="background-color: #ffff00;">建立由 CAD 繪製零件組成的平面四連桿機構 Webots 模擬場景</span></p>
<p style="padding-left: 30px;">各學員請利用 CAD 系統依據 HW1 的連桿尺寸與運動方式, 配置適當大小的旋轉軸以及基座後, 利用 Webots R2025a 完成一個簡單的平面四連桿機構模擬場景.</p>
<p style="padding-left: 30px;">參考資料:</p>
<p style="padding-left: 60px;"><a href="/downloads/fourbar_slvs.7z">fourbar_slvs.7z</a></p>
<p>HW3 (20%):<span style="background-color: #ffff00;">建立 Webots 桌上籃球遊戲機模擬系統</span></p>
<p style="padding-left: 30px;">請各分組利用CAD 系統建立一個能在電腦桌 (1600W X 700D X 740H mm) 上運作的投籃機構 (<a href="https://www.youtube.com/watch?v=LloG_Jn_TI0&amp;t=51s">參考影片</a>)後, 導入 Webots R2025a 套件, 建立一個能由使用者透過鍵盤按鍵操作, 且具備計分板的籃球遊戲機模擬系統.</p>
<p style="padding-left: 30px;">參考資料:</p>
<p>參考資料:</p>
<p style="padding-left: 30px;"><a href="/downloads/fourbar_ball_throwing_linkage.slvs">fourbar_ball_throwing_linkage.slvs</a></p>
<p style="padding-left: 30px;"><a href="/downloads/sixbar_ball_throwing_linkage.slvs">sixbar_ball_throwing_linkage.slvs</a></p>
<p style="padding-left: 30px;"><img alt="" height="264" src="/images/fourbar_ball_throwing_linkage.gif" width="400"/></p>
<h2>HW1</h2>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/Ew6fuEFF3K4" width="560"></iframe></p>
<p></p>
<p><a href="/downloads/HW1.7z">fourbar webots.7z</a></p>
<p>操作流程</p>
<p class="cvGsUA direction-ltr align-start para-style-body"><span class="OYPEnA font-feature-liga-off font-feature-clig-off font-feature-calt-off text-decoration-none text-strikethrough-none">一開始先建一個 robot，然後在它的 children 裡加兩個 hinge joint 跟一個 solid。</span></p>
<p class="cvGsUA direction-ltr align-start para-style-body"><span class="OYPEnA font-feature-liga-off font-feature-clig-off font-feature-calt-off text-decoration-none text-strikethrough-none">solid 的部分我會把它改名叫做 base，然後在它的 children 裡右鍵新增一個 shape，進到 geometry 裡右鍵新增一個 box，然後把 X 的尺寸設成 1 公尺。</span></p>
<p class="cvGsUA direction-ltr align-start para-style-body"><span class="OYPEnA font-feature-liga-off font-feature-clig-off font-feature-calt-off text-decoration-none text-strikethrough-none">（之後就不再重複說明怎麼加 box 的步驟了。）</span></p>
<p class="cvGsUA direction-ltr align-start para-style-body"><span class="OYPEnA font-feature-liga-off font-feature-clig-off font-feature-calt-off text-decoration-none text-strikethrough-none">接著從兩個 hinge joint 任選一個，把它改名成 hinge joint1，另一個就叫 hinge joint4。</span></p>
<p class="cvGsUA direction-ltr align-start para-style-body"><span class="OYPEnA font-feature-liga-off font-feature-clig-off font-feature-calt-off text-decoration-none text-strikethrough-none">接下來點進 hinge joint1，在它的主線程下面，找到 endpoint，右鍵新增一個 solid，然後調整一下它的數值。rotation 的部分可以自己設定，當作是初始角度。</span></p>
<p class="cvGsUA direction-ltr align-start para-style-body"><span class="OYPEnA font-feature-liga-off font-feature-clig-off font-feature-calt-off text-decoration-none text-strikethrough-none">在這個 solid 的 children 裡面，再加一個 pose 跟一個 hinge joint，然後把這個 hinge joint 命名為 joint2。</span></p>
<p class="cvGsUA direction-ltr align-start para-style-body"><span class="OYPEnA font-feature-liga-off font-feature-clig-off font-feature-calt-off text-decoration-none text-strikethrough-none">然後 joint2 的處理方式跟剛剛 joint1 一樣：在 children 裡面新增一個 solid，接著加 pose（放在 box 的中心位置），再加一個 hinge joint，把它命名為 joint3，然後建立第三個 box。</span></p>
<p class="cvGsUA direction-ltr align-start para-style-body"><span class="OYPEnA font-feature-liga-off font-feature-clig-off font-feature-calt-off text-decoration-none text-strikethrough-none">這樣 box 的結構就完成了，接下來要來設定 jointParameters。</span></p>
<p class="cvGsUA direction-ltr align-start para-style-body"><span class="OYPEnA font-feature-liga-off font-feature-clig-off font-feature-calt-off text-decoration-none text-strikethrough-none">jointParameters 的重點是在設定關節相對於原點（0,0,0）的座標位置。舉例來說，如果 link1 的座標相對於原點是往負 X 移動 0.5 公尺，那 anchor 的 X 值就要設成 -0.5m。link2 跟 link3 的設法也是一樣的邏輯。</span></p>
<p class="cvGsUA direction-ltr align-start para-style-body"><span class="OYPEnA font-feature-liga-off font-feature-clig-off font-feature-calt-off text-decoration-none text-strikethrough-none">然後在 joint1 上加一個旋轉馬達，命名為 motor（這會用在後面的控制程式裡）。</span></p>
<p class="cvGsUA direction-ltr align-start para-style-body"><span class="OYPEnA font-feature-liga-off font-feature-clig-off font-feature-calt-off text-decoration-none text-strikethrough-none">最後一個步驟是幫 link1、link2、link3 建立 boundingObject，這個是用來定義物體的物理碰撞範圍的。</span></p>
<p></p>
<p><img alt="" height="106" src="/images/螢幕擷取畫面 2025-06-03 091421.png" width="221"/></p>
<p><img alt="" height="271" src="/images/螢幕擷取畫面 2025-06-03 091502.png" width="493"/></p>
<p><img alt="" height="252" src="/images/螢幕擷取畫面 2025-06-03 092004.png" width="571"/></p>
<p><img alt="" height="268" src="/images/螢幕擷取畫面 2025-06-03 091603.png" width="457"/></p>
<p><img alt="" height="198" src="/images/螢幕擷取畫面 2025-06-03 091631.png" width="576"/></p>
<p><img alt="" height="224" src="/images/螢幕擷取畫面 2025-06-03 091654.png" width="464"/></p>
<p><img alt="" height="259" src="/images/螢幕擷取畫面 2025-06-03 091733.png" width="505"/></p>
<p><img alt="" height="135" src="/images/螢幕擷取畫面 2025-06-03 091811.png" width="488"/></p>
<p><img alt="" height="204" src="/images/螢幕擷取畫面 2025-06-03 091826.png" width="431"/></p>
<p><img alt="" height="251" src="/images/螢幕擷取畫面 2025-06-03 091851.png" width="397"/></p>
<p><img alt="" height="282" src="/images/螢幕擷取畫面 2025-06-03 091910.png" width="443"/></p>
<p><img alt="" height="113" src="/images/螢幕擷取畫面 2025-06-03 092349.png" width="599"/></p>
<p><img alt="" height="94" src="/images/螢幕擷取畫面 2025-06-03 092611.png" width="558"/></p>
<p><img alt="" height="97" src="/images/螢幕擷取畫面 2025-06-03 092704.png" width="602"/></p>
<p></p>
<p><a href="/downloads/fourbar_controller.7z">fourbar_controller.7z</a></p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">from controller import Robot  # 從 Webots 控制器模組匯入 Robot 類別

def run_robot():
    # 建立 Robot 實例
    robot = Robot()

    # 獲取模擬的基本時間步長 (單位：毫秒)
    timestep = int(robot.getBasicTimeStep())

    # 取得名為 'motor' 的馬達裝置
    motor = robot.getDevice('motor')

    # 設定馬達為無限旋轉模式（連續轉動，不是轉到特定角度）
    motor.setPosition(float('inf'))

    # 設定馬達旋轉速度為 1.0 弧度/秒
    motor.setVelocity(1.0)

    # 主控制迴圈：只要模擬沒結束，就一直執行
    while robot.step(timestep) != -1:
        pass  # 目前不需要在每個時間步做額外的動作

# 如果此檔案是直接執行的，呼叫 run_robot() 函式
if __name__ == "__main__":
    run_robot()
</pre>
<p></p>
<p>心得：這是第一次使用webots，過程當中遇到超多問題，一開始是如何做設置、模擬程式導入許多問題，好險問同學之後慢慢地學會使用。</p>
<p></p>
<p>HW1 (5%): <span style="background-color: #ffff00;">建立由 Box 組成的平面四連桿機構 Webots 模擬場景</span></p>
<p>操作影片標題: 國立虎尾科技大學 - 機械設計工程系 - cd2025 HW1 - 學員學號</p>
<p></p>
<h2>HW2</h2>
<p>繪製檔案轉obj</p>
<p>檔案：<a href="/downloads/split_parts.7z">fourbar obj</a></p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/DUMgoqvI5jU" width="560"></iframe></p>
<p></p>
<p>作業檔案：<a href="/downloads/fourbar webots.7z">fourbar webots.7z</a></p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/lv79jDls2D0" width="560"></iframe></p>
<p>作業流程</p>
<p class="cvGsUA direction-ltr align-justify para-style-body"><span class="OYPEnA font-feature-liga-off font-feature-clig-off font-feature-calt-off text-decoration-none text-strikethrough-none">在solvespace繪製零件並將組裝好整個機構之後，先把檔案存起來，接著輸出一個 .stl 檔。</span></p>
<p class="cvGsUA direction-ltr align-justify para-style-body"><span class="OYPEnA font-feature-liga-off font-feature-clig-off font-feature-calt-off text-decoration-none text-strikethrough-none">然後用 split_stl_to_obj_scale2 這個工具把 .stl 轉成 .obj</span></p>
<p class="cvGsUA direction-ltr align-justify para-style-body"><span class="OYPEnA font-feature-liga-off font-feature-clig-off font-feature-calt-off text-decoration-none text-strikethrough-none">接下來進入 Webots後，先在場景裡加入一個 Robot 群組。</span></p>
<p class="cvGsUA direction-ltr align-justify para-style-body"><span class="OYPEnA font-feature-liga-off font-feature-clig-off font-feature-calt-off text-decoration-none text-strikethrough-none">在這個 Robot 裡的 children 加入兩個 Solid 當作是base，再加兩個 HingeJoint，其中一個命名成 joint1，另一個是 joint4。</span></p>
<p class="cvGsUA direction-ltr align-justify para-style-body"><span class="OYPEnA font-feature-liga-off font-feature-clig-off font-feature-calt-off text-decoration-none text-strikethrough-none">，再接下來的操作和 HW1 差不多，差別在於HW1的 box是用內建，而這次不是用內建的，而是使用自己在solvespace畫好的模型匯入。要將檔案匯入有兩種方式：第一個是用 CadShape 匯入 .obj，第二個是用 Shape -&gt; Mesh 來匯入。而我選擇Shape -&gt; Mesh，這樣比較方便調整顏色。</span></p>
<p></p>
<p><img alt="" height="339" src="/images/螢幕擷取畫面 2025-06-03 093922.png" width="468"/></p>
<p><img alt="" height="198" src="/images/螢幕擷取畫面 2025-06-03 093953.png" width="448"/></p>
<p><img alt="" height="226" src="/images/螢幕擷取畫面 2025-06-03 094023.png" width="456"/></p>
<p><img alt="" height="253" src="/images/螢幕擷取畫面 2025-06-03 094225.png" width="585"/></p>
<p><img alt="" height="293" src="/images/螢幕擷取畫面 2025-06-03 094408.png" width="489"/></p>
<p><img alt="" height="112" src="/images/螢幕擷取畫面 2025-06-03 094439.png" width="455"/></p>
<p><img alt="" height="259" src="/images/螢幕擷取畫面 2025-06-03 094500.png" width="398"/></p>
<p><img alt="" height="108" src="/images/螢幕擷取畫面 2025-06-03 094512.png" width="286"/></p>
<p><img alt="" height="206" src="/images/螢幕擷取畫面 2025-06-03 094542.png" width="419"/></p>
<p><img alt="" height="132" src="/images/螢幕擷取畫面 2025-06-03 094554.png" width="292"/></p>
<p><img alt="" height="130" src="/images/螢幕擷取畫面 2025-06-03 094613.png" width="359"/></p>
<p><img alt="" height="93" src="/images/螢幕擷取畫面 2025-06-03 094659.png" width="399"/></p>
<p><img alt="" height="96" src="/images/螢幕擷取畫面 2025-06-03 094724.png" width="390"/></p>
<p></p>
<p>心得：這次作業是使用自己所畫的圖檔，導入webots做使用，在這之前需要先將檔案會成obj，一開始我是使用<span class="OYPEnA font-feature-liga-off font-feature-clig-off font-feature-calt-off text-decoration-none text-strikethrough-none">solvespace直接匯出導入webots後，發現變超級大的，原來webots所使用的單位是m公尺，所以我們所繪製的圖與變成了m公尺，後來才得知是需要使用split_stl_to_obj_scale2 這個工具，轉出轉換單位的obj才得以解決。</span></p>
<p>HW2 (5%): <span style="background-color: #ffff00;">建立由 CAD 繪製零件組成的平面四連桿機構 Webots 模擬場景</span></p>
<p>操作影片標題: 國立虎尾科技大學 - 機械設計工程系 - cd2025 HW2 - 學員學號</p>
<p></p>
<h2>HW3</h2>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/2FHkLTmIFPo" width="560"></iframe></p>
<p></p>
<p><span>作業檔案：</span><a href="/downloads/basketball shoot webots.zip">basketball shoot webots.zip</a></p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/0gJGNhaHbIg" width="560"></iframe></p>
<p>作業流程</p>
<p></p>
<p><span class="OYPEnA font-feature-liga-off font-feature-clig-off font-feature-calt-off text-decoration-none text-strikethrough-none">本次作業和HW2流程一樣，需要先將圖檔繪製好組裝好，並將檔案匯出成.obj，再進到webots做組裝，而這次比較特別別的是有增加一顆球和籃框，目標是要將開啟模擬時可以將球投入籃框。</span></p>
<p><img alt="" height="152" src="/images/螢幕擷取畫面 2025-06-03 095726.png" width="391"/></p>
<p><img alt="" height="370" src="/images/螢幕擷取畫面 2025-06-03 100321.png" width="451"/></p>
<p><img alt="" height="223" src="/images/螢幕擷取畫面 2025-06-03 095924.png" width="352"/></p>
<p><img alt="" height="184" src="/images/螢幕擷取畫面 2025-06-03 095950.png" width="316"/></p>
<p><img alt="" height="187" src="/images/螢幕擷取畫面 2025-06-03 100021.png" width="413"/></p>
<p><img alt="" height="180" src="/images/螢幕擷取畫面 2025-06-03 100052.png" width="347"/></p>
<p><img alt="" height="147" src="/images/螢幕擷取畫面 2025-06-03 100113.png" width="312"/></p>
<p><img alt="" height="202" src="/images/螢幕擷取畫面 2025-06-03 100127.png" width="273"/></p>
<p><img alt="" height="127" src="/images/螢幕擷取畫面 2025-06-03 101332.png" width="273"/></p>
<p><img alt="" height="197" src="/images/螢幕擷取畫面 2025-06-03 100156.png" width="351"/></p>
<p><img alt="" height="201" src="/images/螢幕擷取畫面 2025-06-03 100226.png" width="439"/></p>
<p><img alt="" height="89" src="/images/螢幕擷取畫面 2025-06-03 100407.png" width="335"/></p>
<p><img alt="" height="96" src="/images/螢幕擷取畫面 2025-06-03 101905.png" width="484"/></p>
<p><img alt="" height="292" src="/images/螢幕擷取畫面 2025-06-03 100459.png" width="450"/></p>
<p><img alt="" height="364" src="/images/螢幕擷取畫面 2025-06-03 100528.png" width="474"/></p>
<p>心得：這次的作業做起來相對於之前兩次順手，這次一樣是要先繪製、轉檔案再進入webots做操作，這次比較特別的就是多加了籃框和一顆球，而球的部分我一開始以為是要自己繪製，但後來再做設置的時候感覺怪怪的，詢問同學後才知道內建就有球體可做使用，害我還花時間去畫一顆球轉檔來用。</p>
<p></p>
<p>作業檔案：<a href="/downloads/basketball hoop webots.7z">basketball hoop webots.7z</a></p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false"># 從 Webots 的 controller 模組中導入 Robot 類別
from controller import Robot

# 定義主函式
def run_robot():
    # 建立一個 Robot 實例，用來與模擬中的機器人互動
    robot = Robot()

    # 取得模擬的基本時間步長（以毫秒為單位）
    timestep = int(robot.getBasicTimeStep())

    # 取得名為 'motor1' 的馬達裝置
    motor = robot.getDevice('motor1')

    # 取得鍵盤裝置，並啟用以便後續讀取輸入
    keyboard = robot.getKeyboard()
    keyboard.enable(timestep)  # 啟用鍵盤裝置，並設定掃描間隔為 timestep

    # 設定馬達的初始位置（此處未實際使用，但可作為預設值）
    initial_position = 0.0  # 假設初始位置為 0 弧度

    # 主要控制迴圈，每次迴圈會根據 timestep 推進模擬
    while robot.step(timestep) != -1:
        # 將馬達的位置設定為 38 度（轉換為弧度後設為目標位置）
        motor.setPosition(38 * 3.14159 / 180)

# 如果這個程式是主程式執行，則呼叫主函式
if __name__ == "__main__":
    run_robot()
</pre>
<p></p>
<p>作業檔案：<a href="/downloads/basketball shoot webots.zip">basketball shoot webots.zip</a></p>
<p>HW3 (20%):<span style="background-color: #ffff00;">建立 Webots 桌上籃球遊戲機模擬系統</span></p>
<p>操作影片標題: 國立虎尾科技大學 - 機械設計工程系 - cd2025 HW3 - 學員學號</p>
<p></p>
<h1>Midterm</h1>
<p>各週進度:<span>可攜更改python 313、學員名單、小組名單、四連桿繪製組裝</span></p>
<p>各週網頁內容:<a href="https://mdecd2025.github.io/hw-41223230/content/task1.html">task1</a>、<a href="https://mdecd2025.github.io/hw-41223230/content/list.html">task1 list</a>、<a href="https://mdecd2025.github.io/hw-41223230/content/task2.html">task2</a>、<a href="https://mdecd2025.github.io/hw-41223230/content/task4.html">task4</a></p>
<p>期中心得:上完九週的課程，個人覺得這門課比上一門課困難許多，而且目前作業進度落後，需要多加跟上。</p>
<p>期中自評影片</p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/mzSeBFppqBg" width="560"></iframe></p>
<p></p>
<p style="padding-left: 30px;"></p>
<h1>Exam</h1>
<p>Exam1 (10%): 建立 Webots 基本物件模擬場景</p>
<p style="padding-left: 30px;">各學員利用 Webots R2025a 套件中的 Shape 物件, 隨堂建立指定的機電系統模擬場景, 並利用 Python 程式進行互動控制.</p>
<p>Exam2 (10%): 利用 CAD 零組件建立模擬場景 </p>
<p style="padding-left: 30px;">各學員利用 CAD (Solvespace 與 NX2312), 隨堂建立指定的系統模型零組件後, 導入 Webots R2025a 後, 建立機電系統模擬場景, 並利用 Python 程式進行互動控制.</p>
<p>Exam3 (20%): Webots 機電模擬場景的協同設計</p>
<p style="padding-left: 30px;">各分組利用 CAD (Solvespace 與 NX2312), 隨堂建立指定的系統模型零組件後, 導入 Webots R2025a 後, 建立機電系統模擬場景, 並利用 Python 程式進行互動控制. 過程中各學員必須採同步協同模式, 維護從 Github Classroom 取得的分組協同倉儲以及網站.</p>
<p style="padding-left: 30px;">協同分組方式:</p>
<ol>
<li>分配學員負責利用 Solvespace 建立系統零組件, 過程中必須將所建構之零組件檔案與繪圖過程影片上傳至分組網頁.</li>
<li>分配學員負責利用 NX2312 建立系統零組件, 過程中必須將所建構之零組件檔案與繪圖過程影片上傳至分組網頁.</li>
<li>分配學員負責利用 Webots 建立機電系統模擬場景, 並利用 Python 程式進行控制, 過程中必須將建構過程拍成帶有說明字幕的影片上傳至分組網頁.</li>
</ol>
<h2>Exam1</h2>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/pbTT2thODIQ" width="560"></iframe></p>
<p></p>
<p>作業檔案：<a href="/downloads/exam1.7z">exam1</a></p>
<p>過程：<br/>1.首先我們在做exam1前要先去solvespace內畫出我們除了起始角30度以外的角度，繪畫完後得到我們link1為30度、limk2為41.79度、link3為130.6度。<br/>2.這三個角度轉為弳度為0.523599、0.729373、2.2794<br/>3.這次作業使用HW1的檔案下去做修改<br/>4.首先展開joint1裡面link1的rotation內的angle改為0.523599<br/>5.再來是展開joint2裡面link2的rotation內的angle改為0.724137<br/>6.最後展開joint3裡面link3的rotation內的angle改為2.2794<br/>7.回到link2的children，再加入一個pose，展開裡面的translation XYZ改為0.3、0.2、0；pose內children加入shape<br/>8.shape內的geometry加入box，將size XYZ改為0.1、0.3、0.1<br/>9.最後儲存，開啟模擬成功<br/>心得：<br/>這次的exam1，使用先前HW1下去做更改，一開始一個一找要更改的部分，前後約使用1個小時，然後成功後再錄影，錄完約6分鐘，完整地做完後對於整體架構又更加理解。</p>
<p></p>
<p>Exam1 (10%): 建立 Webots 基本物件模擬場景</p>
<p>操作影片標題: 國立虎尾科技大學 - 機械設計工程系 - cd2025 Exam1 - 學員學號</p>
<h2>Exam2</h2>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/-Ep97y43Vko" width="560"></iframe></p>
<p></p>
<p>考試檔案：<a href="/downloads/slvs.7z">slvs</a>、<a href="/downloads/webots.7z">webots</a></p>
<p>過程<br/>1.首先先計算主動桿改為1.30m時，固定桿和從動桿為多少；最後得出固定桿3.25m、從動桿為1.95m和2.925m<br/>2.依照這個尺寸在solvespace繪製線架構，並求出起始角以外的角度；<br/>3.繪製完線架構後，開始繪製新的shape，並進行組裝<br/>4.全部繪製、組裝完後，使用split_stl_to_obj_scale2.py這個程式去匯出obj<br/>5.結束後打開webots開始設置，流程和HW2一樣，完成後開啟模擬檢查是否正確<br/>心得<br/>在這次的作業讓我深深體會到第一步錯就會導致後面就全錯，由於一開始的線架構我將原點設置在中間，並不是設置在最左邊，所以導致在設置joint4的jointparameters內的anchor無法設置正確，最後只好重新繪製線架構和組裝在繪出新的obj再做一次，得以完成。</p>
<p></p>
<p>Exam2 (10%): 利用 CAD 零組件建立模擬場景</p>
<p>操作影片標題: 國立虎尾科技大學 - 機械設計工程系 - cd2025 Exam2 - 學員學號</p>
<h2>Exam3</h2>
<p>Exam3-1</p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/qYnA66lMfek" width="560"></iframe></p>
<p>Exam3-2</p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/EdrX2_ALsAk" width="560"></iframe></p>
<p>Exam3-3</p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/fOA3nyRczBc" width="560"></iframe></p>
<p></p>
<p>過程與心得</p>
<p>1.首先先到<a href="https://mde.tw/cd2025/content/IPv6.html">https://mde.tw/cd2025/content/IPv6.html</a>這個網頁找到自己的ipv6</p>
<p>2.到電腦控制台、網際網路、乙太網路、內容ipv6做更改</p>
<p>3.完成後打開cmd 打入<span>webot --stream  "檔案路徑\檔名.wbt</span></p>
<p><span>4.正確打開webots後，打開瀏覽器到<a href="http://localhost:1234/index.html網頁">http://localhost:1234/index.html</a></span></p>
<p><span>5.進入後先按connect，測試是否連上</span></p>
<p><span>6.成功連上後將上面改成ws://[自己的ipv6]:1234</span></p>
<p><span>7.成功連接上後，代表成功</span></p>
<p><span>心得</span></p>
<p><span>一開始看網頁上的敘述作業內容看的是一頭霧水，後來請教同學後才知道整個如何操作，這整個是透過<a href="http://localhost:1234/index.html%E7%B6%B2%E9%A0%81">http://localhost:1234/index.html</a> 這個網頁來達到串流。</span></p>
<p><span></span></p>
<p>Exam3 (20%): Webots 機電模擬場景的協同設計</p>
<p>操作影片標題: 國立虎尾科技大學 - 機械設計工程系 - cd2025 Exam3 - 學員學號</p>
<h1>Final</h1>
<p><span></span></p>
<p><span>說明:</span></p>
<p><span>PDf 報告檔案：<a href="/downloads/Webots 動態投籃模擬系統的協同設計(第7組).pdf">Webots 動態投籃模擬系統的協同設計(第7組).pdf</a></span></p>
<p><span>作業檔案webots：2025a版</span><span> <a href="/downloads/final.7z">final.7z</a></span></p>
<p>                      : 2023b版 <a href="/downloads/final test.7z">final test.7z</a></p>
<p><span> shooter youbots</span></p>
<p><span><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/btS_oS0Yi3s" width="560"></iframe></span><span></span></p>
<p><span>supervisor Robots</span></p>
<p><span><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/35r1Lzf8CfI" width="560"></iframe></span><span></span></p>
<p><span>stand youbots</span></p>
<p><span><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/MEkjQxztVBk" width="560"></iframe></span></p>
<p><span></span></p>
<p><span> transform</span></p>
<p><span><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/N8mVPtXQk_4" width="560"></iframe></span></p>
<p><span></span></p>
<p><span>counter supervisor</span></p>
<p><span><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/QqPwNuadrq0" width="560"></iframe></span></p>
<p><span></span></p>
<p>final</p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/WigggjIry8o" width="560"></iframe></p>
<p><span></span></p>
<p><span>期末協同專案執行過程影片、簡報與 PDf 報告檔案 (六人一組) (30%)</span></p>
<p><span>題目: <span style="background-color: #ccffcc;">Webots 動態投籃模擬系統的協同設計</span></span></p>
<p style="padding-left: 30px;"><span>籃框架被配置在一定範圍內, 可隨機慢速前進、後退及左右擺動, 投籃機構系統帶有一定數量的籃球, 被配置在可自由移動的輪車上.</span></p>
<p style="padding-left: 30px;"><span>操作者可利用鍵盤特定按鍵控制投籃輪車的移動並發射投籃, 每投出一球後系統透過記分板進行計分, 並由送球機構進行補球或移動輪車取球, 遊戲可進行至全部數量籃球投完為止.</span></p>
<p>請將期末協同專案執行過程、內容與心得, 製作成影片，配合字幕上傳至 Youtube 後嵌入各階段的期末報告頁面中.</p>
<p>影片標題: <span style="background-color: #ffff00;">國立虎尾科技大學 - 機械設計工程系 - cd2025 期末報告 - 學員學號 - 各階段影片主題<br/></span></p>
<h2>shooter youbots</h2>
<p></p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">from controller import Robot, Keyboard  # 匯入 Webots 控制所需的 Robot 和 Keyboard 類別

# 常數設定
TIME_STEP = 32  # 控制循環的時間間隔（毫秒）
MAX_VELOCITY = 10.0  # 車輪最大速度
ANGLE_STEP = 40 * 3.14159 / 180  # 將 40 度轉換為弧度（機構用角度）
POSITION_M = ANGLE_STEP          # 機構移動至 +40 度的位置
POSITION_K = 0.0                 # 機構移動至 0 度的位置

# 初始化機器人與鍵盤
robot = Robot()  # 創建 Robot 物件
timestep = int(robot.getBasicTimeStep())  # 取得機器人基礎時間步長
keyboard = Keyboard()  # 創建鍵盤物件
keyboard.enable(timestep)  # 啟用鍵盤偵測，使用相同時間步長

# 嘗試取得馬達與感測器裝置
try:
    motor = robot.getDevice('motor1')  # 取得名為 motor1 的馬達裝置
    sensor = robot.getDevice('motor1_sensor')  # 取得與馬達對應的感測器
    sensor.enable(timestep)  # 啟用感測器以讀取資料
    mechanism_enabled = True  # 成功取得裝置，啟用機構控制
except Exception:
    mechanism_enabled = False  # 若出錯（裝置不存在），則停用機構功能

# 嘗試取得車輪裝置
try:
    wheels = [robot.getDevice(f"wheel{i+1}") for i in range(4)]  # 取得四個車輪裝置
    for wheel in wheels:
        wheel.setPosition(float('inf'))  # 設為無限位置，開啟速度控制模式
        wheel.setVelocity(0)  # 初始速度設為 0
    platform_enabled = True  # 若成功取得裝置，啟用平台控制
except Exception:
    platform_enabled = False  # 若取得失敗，停用平台功能

# 狀態機初始狀態：允許按 F 鍵動作
current_state = "allow_f"

# 記錄按鍵是否已被按下，用於去彈跳（避免重複觸發）
key_pressed = {
    'v': False,  # 記錄 V 鍵是否被按下
    'f': False   # 記錄 F 鍵是否被按下
}

# 主循環，重複執行直到模擬結束
while robot.step(timestep) != -1:
    key = keyboard.getKey()  # 讀取目前按下的鍵

    # 平台控制（移動用輪子）
    if platform_enabled:
        if key == Keyboard.UP:
            for wheel in wheels:
                wheel.setVelocity(MAX_VELOCITY)  # 所有輪子向前
        elif key == Keyboard.DOWN:
            for wheel in wheels:
                wheel.setVelocity(-MAX_VELOCITY)  # 所有輪子向後
        elif key == Keyboard.LEFT:
            # 左轉（左右輪反方向旋轉）
            wheels[0].setVelocity(MAX_VELOCITY)
            wheels[1].setVelocity(-MAX_VELOCITY)
            wheels[2].setVelocity(MAX_VELOCITY)
            wheels[3].setVelocity(-MAX_VELOCITY)
        elif key == Keyboard.RIGHT:
            # 右轉（左右輪反方向旋轉）
            wheels[0].setVelocity(-MAX_VELOCITY)
            wheels[1].setVelocity(MAX_VELOCITY)
            wheels[2].setVelocity(-MAX_VELOCITY)
            wheels[3].setVelocity(MAX_VELOCITY)
        elif key == ord('Q') or key == ord('q'):
            print("Exiting...")  # 按 Q 結束程式
            break
        else:
            for wheel in wheels:
                wheel.setVelocity(0)  # 沒有方向鍵按下時停止移動

    # 馬達控制（用 F / V 鍵操作）
    if mechanism_enabled:
        _current_motor_position = sensor.getValue()  # 讀取馬達目前位置（可用於除錯）

        # 按下 F 鍵時，若允許且尚未按住，讓馬達轉到 +40 度
        if key == ord('F') or key == ord('f'):
            if not key_pressed['f'] and current_state == "allow_f":
                motor.setPosition(POSITION_M)  # 馬達移動至 +40 度
                current_state = "allow_v"  # 下一次只能按 V
            key_pressed['f'] = True  # 標記 F 鍵已按
        else:
            key_pressed['f'] = False  # F 鍵已放開

        # 按下 V 鍵時，若允許且尚未按住，讓馬達轉回 0 度
        if key == ord('V') or key == ord('v'):
            if not key_pressed['v'] and current_state == "allow_v":
                motor.setPosition(POSITION_K)  # 馬達移動至 0 度
                current_state = "allow_f"  # 下一次只能按 F
            key_pressed['v'] = True  # 標記 V 鍵已按
        else:
            key_pressed['v'] = False  # V 鍵已放開
</pre>
<p><span></span></p>
<p><span>在原本的城市當中是以M和K作為發射和回復，但我個人覺得有點不習慣，所以就改成了F和V</span></p>
<h2>supervisor Robots</h2>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">from controller import Supervisor, Keyboard  # 匯入 Webots 的 Supervisor 和鍵盤控制模組
import time                                   # 匯入時間模組，用於記錄與計時
import random                                 # 匯入隨機模組，用於顏色和命名
import numpy as np                            # 匯入 NumPy，用來處理向量運算
import re                                     # 匯入正規表達式模組，用來比對 DEF 名稱

# ----------------- 參數區 -----------------
HOOP_CENTER = [0.622, -0.103, 0.742838]       # 籃框中心座標
BALL_DEF_PATTERN = re.compile(r"Sphere_\d+")  # 比對球的 DEF 名稱用的正則表達式

supervisor = Supervisor()                     # 建立 Webots 的 Supervisor 實例
timestep = int(supervisor.getBasicTimeStep()) # 取得模擬時間步長
keyboard = Keyboard()                         # 建立鍵盤控制實例
keyboard.enable(timestep)                     # 啟用鍵盤，並設定更新頻率為 timestep

# 球與軌跡點設定
sphere_radius = 0.1
TRAJECTORY_POINT_RADIUS = 0.03                # 軌跡球的半徑
TRAJECTORY_POINT_STEP = 0.12                  # 軌跡點之間的最小距離
TRAJECTORY_MAX_POINTS = 5                     # 最多顯示5個軌跡點

# 狀態變數初始化
waiting_ball_def = None                       # 等待發射的球的 DEF 名稱
waiting_ball_info = None                      # 等待發射球的資訊（位置與顏色）
last_key_time = 0                             # 上一次按鍵時間（防止重複觸發）
debounce_time = 0.5                           # 按鍵去彈時間（秒）
default_feed_pos = (-0.35, 0.0, 0.9)           # 新球產生時的相對位置
PRINT_INTERVAL = 0.2                          # 球座標輸出間隔

current_tracked_def = None                    # 目前追蹤的球 DEF 名稱
last_print_time = time.time()                 # 上次輸出時間

trajectory_points = []                        # 保存目前的軌跡點 [(位置, def名稱)] 最多5個

# ----------------- 函式定義 -----------------

# 將軸角轉換為旋轉矩陣（用於從 local 座標轉為 world 座標）
def axis_angle_to_rotation_matrix(axis, angle):
    x, y, z = axis
    c = np.cos(angle)
    s = np.sin(angle)
    C = 1 - c
    return np.array([
        [x*x*C + c,   x*y*C - z*s, x*z*C + y*s],
        [y*x*C + z*s, y*y*C + c,   y*z*C - x*s],
        [z*x*C - y*s, z*y*C + x*s, z*z*C + c]
    ])

# 產生獨一無二的球名稱（根據時間戳與亂數）
def generate_valid_def_name(base_name="Sphere"):
    timestamp = int(supervisor.getTime() * 1000)
    return f"{base_name}_{timestamp}_{random.randint(0, 10000)}"

# 產生隨機 RGB 顏色
def generate_random_color():
    return random.random(), random.random(), random.random()

# 將 youbot 上的 local 座標轉成 world 座標
def youbot_local_to_world(local_pos):
    youbot_node = supervisor.getFromDef('youbot')
    if youbot_node is None:
        raise RuntimeError("找不到 DEF 為 youbot 的 Robot 物件")
    youbot_translation = np.array(youbot_node.getField('translation').getSFVec3f())
    youbot_rotation = youbot_node.getField('rotation').getSFRotation()
    youbot_axis = youbot_rotation[:3]
    youbot_angle = youbot_rotation[3]
    youbot_rot_mat = axis_angle_to_rotation_matrix(youbot_axis, youbot_angle)
    rotated = youbot_rot_mat @ np.array(local_pos)
    world_pos = youbot_translation + rotated
    return tuple(world_pos)

# 建立靜止球（不含物理）
def create_static_ball(def_name, world_pos, r, g, b):
    sphere_string = f"""
    DEF {def_name} Solid {{
      translation {world_pos[0]} {world_pos[1]} {world_pos[2]}
      contactMaterial "ball"
      children [
        Shape {{
          geometry Sphere {{
            radius {sphere_radius}
          }}
          appearance Appearance {{
            material Material {{
              diffuseColor {r} {g} {b}
            }}
          }}
        }}
      ]
      boundingObject Sphere {{
        radius {sphere_radius}
      }}
    }}
    """
    root = supervisor.getRoot()
    children_field = root.getField("children")
    children_field.importMFNodeFromString(-1, sphere_string)

# 建立動態球（可以被物理模擬推動）
def create_dynamic_ball(def_name, world_pos, r, g, b):
    sphere_string = f"""
    DEF {def_name} Solid {{
      translation {world_pos[0]} {world_pos[1]} {world_pos[2]}
      contactMaterial "ball"
      children [
        Shape {{
          geometry Sphere {{
            radius {sphere_radius}
          }}
          appearance Appearance {{
            material Material {{
              diffuseColor {r} {g} {b}
            }}
          }}
        }}
      ]
      boundingObject Sphere {{
        radius {sphere_radius}
      }}
      physics Physics {{
        mass 0.01
        density -1
      }}
    }}
    """
    root = supervisor.getRoot()
    children_field = root.getField("children")
    children_field.importMFNodeFromString(-1, sphere_string)

# 建立軌跡小球作為可視化記號（Transform + Shape，無物理）
def create_trajectory_point(pos):
    def_name = generate_valid_def_name("TrajectoryPt")
    sphere_string = f"""
    DEF {def_name} Transform {{
      translation {pos[0]} {pos[1]} {pos[2]}
      children [
        Shape {{
          geometry Sphere {{
            radius {TRAJECTORY_POINT_RADIUS}
          }}
          appearance Appearance {{
            material Material {{
              diffuseColor 1 0.7 0
              transparency 0.3
            }}
          }}
        }}
      ]
    }}
    """
    root = supervisor.getRoot()
    children_field = root.getField("children")
    children_field.importMFNodeFromString(-1, sphere_string)
    return def_name

# 刪除目前所有軌跡點
def delete_trajectory_points():
    global trajectory_points
    for _, def_name in trajectory_points:
        node = supervisor.getFromDef(def_name)
        if node:
            node.remove()
    trajectory_points.clear()

# 建立一顆靜止球（並儲存它的資訊）
def create_static_sphere(supervisor, x, y, z):
    global waiting_ball_def, waiting_ball_info
    def_name = generate_valid_def_name()
    waiting_ball_def = def_name
    r, g, b = generate_random_color()
    world_pos = youbot_local_to_world((x, y, z))
    waiting_ball_info = (world_pos, r, g, b)
    create_static_ball(def_name, world_pos, r, g, b)

# 將靜止球移除並改為物理球
def activate_dynamic_ball():
    global waiting_ball_def, waiting_ball_info
    if waiting_ball_def is None or waiting_ball_info is None:
        return
    ball_node = supervisor.getFromDef(waiting_ball_def)
    if ball_node is not None:
        ball_node.remove()
        supervisor.step(int(supervisor.getBasicTimeStep()))
    world_pos, r, g, b = waiting_ball_info
    create_dynamic_ball(waiting_ball_def, world_pos, r, g, b)
    waiting_ball_def = None
    waiting_ball_info = None

# 判斷球是否落地（以 z 軸高度為依據）
def is_ball_landed(pos, threshold_z=0.13):
    return pos[2] &lt; threshold_z

# ----------------- 主迴圈 -----------------

print("按 R 產生一顆靜止球，按 F 讓球變 dynamic 可擊出（最多只有5個軌跡點跟著球跑，球落地後軌跡自動消失）")

while supervisor.step(timestep) != -1:
    key = keyboard.getKey()
    current_time = time.time()

    # 按 R 鍵產生一顆靜止球
    if key == ord('R') and (current_time - last_key_time &gt;= debounce_time):
        if waiting_ball_def is None:
            create_static_sphere(supervisor, *default_feed_pos)
            current_tracked_def = waiting_ball_def
            delete_trajectory_points()
        else:
            print("還有一顆球等待擊出，請先擊出再產生新球。")
        last_key_time = current_time

    # 按 F 鍵讓球變成可被物理推動（Dynamic）
    if key == ord('F') and (current_time - last_key_time &gt;= debounce_time):
        activate_dynamic_ball()
        last_key_time = current_time

    # 若目前有追蹤的球，就更新軌跡顯示與落地檢查
    if current_tracked_def is not None:
        ball_node = supervisor.getFromDef(current_tracked_def)
        if ball_node is not None:
            pos = ball_node.getPosition()
            if current_time - last_print_time &gt;= PRINT_INTERVAL:
                # print(f"球 {current_tracked_def} 絕對座標: [{pos[0]:.4f}, {pos[1]:.4f}, {pos[2]:.4f}]")
                last_print_time = current_time

            # 若與上一個軌跡點距離足夠遠，新增新的軌跡點
            if (not trajectory_points) or np.linalg.norm(np.array(pos) - np.array(trajectory_points[-1][0])) &gt; TRAJECTORY_POINT_STEP:
                def_name = create_trajectory_point(pos)
                trajectory_points.append((pos, def_name))
                if len(trajectory_points) &gt; TRAJECTORY_MAX_POINTS:
                    _, old_def = trajectory_points.pop(0)
                    node = supervisor.getFromDef(old_def)
                    if node:
                        node.remove()

            # 若球落地，刪除軌跡
            if is_ball_landed(pos):
                delete_trajectory_points()
        else:
            delete_trajectory_points()
            current_tracked_def = None
</pre>
<p><span></span></p>
<p><span>在這程式當中我將原本的A鍵給球變成R鍵給球，然後還有先前的shooter youbots的發射鍵改成F，所以在這邊的M也需要改成F，以免在原本執行上出問題。</span></p>
<h2>stand youbots</h2>
<p></p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">from controller import Robot, Keyboard  # 匯入 Webots 提供的 Robot 與 Keyboard 類別

# 常數定義
WHEEL_RADIUS = 0.1  # 輪子的半徑（單位：公尺），此處為 10 公分
L = 0.471  # 機器人長度的一半（用於動力學計算）
W = 0.376  # 機器人寬度的一半
MAX_VELOCITY = 10.0  # 輪子的最大速度（單位：rad/s）

# 初始化機器人實體
robot = Robot()

# 取得模擬的時間步長（time step）
timestep = int(robot.getBasicTimeStep())

# 取得發射器裝置，用於傳送分數（與其他模組或裝置通訊）
emitter = robot.getDevice("score_emitter")

score_to_send = 2  # 每次感測成功後加分數，這裡設為 2 分，可自行調整

# 初始化距離感測器（距離球進入感測區的偵測裝置）
sensor = robot.getDevice('sensor')  # 取得感測器裝置
sensor.enable(timestep)  # 啟用感測器並設定刷新速率

score = 0  # 初始分數
last_score_time = 0  # 上一次得分的時間
cooldown = 1.0  # 冷卻時間（秒），防止重複計分

# 初始化鍵盤控制器
keyboard = Keyboard()
keyboard.enable(timestep)  # 啟用鍵盤偵測並設定刷新速率

# 取得四個馬達裝置（四輪全驅）
wheel5 = robot.getDevice("wheel5")  # 前右輪
wheel6 = robot.getDevice("wheel6")  # 前左輪
wheel7 = robot.getDevice("wheel7")  # 後右輪
wheel8 = robot.getDevice("wheel8")  # 後左輪

# 設定輪子為速度控制模式（inf 表示不限制旋轉角度）
for wheel in [wheel5, wheel6, wheel7, wheel8]:
    wheel.setPosition(float('inf'))  # 設定為速度控制（非位置控制）
    wheel.setVelocity(0)  # 初始速度為 0（靜止）

# 定義控制四個輪子速度的函式
def set_wheel_velocity(v1, v2, v3, v4):
    """設定每個輪子的速度"""
    wheel5.setVelocity(v1)
    wheel6.setVelocity(v2)
    wheel7.setVelocity(v3)
    wheel8.setVelocity(v4)

# 將感測器AD值對應到距離的查表函式（線性插值）
lookup_table = [
    (1000, 0.00),
    (620, 0.12),
    (372, 0.13),
    (248, 0.14),
    (186, 0.15),
    (0, 0.18)
]

# 根據感測器的AD值推算實際距離（單位：公尺）
def ad_to_distance(ad_value):
    # AD 值遞減時表示距離遞增（感測器邏輯）
    for i in range(len(lookup_table)-1):
        a0, d0 = lookup_table[i]
        a1, d1 = lookup_table[i+1]
        if a1 &lt;= ad_value &lt;= a0:
            # 線性插值公式：在 a0 和 a1 之間計算距離值
            return d0 + (d1 - d0) * (ad_value - a0) / (a1 - a0)
    # 若超出表格範圍則回傳邊界值
    if ad_value &gt; lookup_table[0][0]:
        return lookup_table[0][1]
    return lookup_table[-1][1]

# 主迴圈開始，負責持續讀取感測器與鍵盤輸入
print("Use 'W', 'S', 'A', 'D' keys to control the robot.")
print("W: Move forward, S: Move backward, A: Turn left, D: Turn right.")
print("Press 'Q' to quit.")

while robot.step(timestep) != -1:  # 每次時間步進（直到模擬結束）

    key = keyboard.getKey()  # 讀取目前按下的鍵

    # 讀取距離感測器數值
    sensor_value = sensor.getValue()
    distance = ad_to_distance(sensor_value)  # 轉換成距離（公尺）

    current_time = robot.getTime()  # 取得當前模擬時間

    # 如果按下 F 鍵，印出目前距離（除錯用）
    if key == ord('F') or key == ord('f'):
        print(distance)

    # 如果按下 V 鍵，也印出距離（除錯用）
    if key == ord('V') or key == ord('v'):
        print(distance)

    # 若感測距離小於 0.11 公尺，且超過冷卻時間，則加分
    if distance &lt; 0.11 and (current_time - last_score_time) &gt; cooldown:
        score += 2
        print("得分")  # 顯示得分訊息
        print(distance)  # 顯示當前距離
        emitter.send(str(score_to_send).encode('utf-8'))  # 傳送分數給外部（如顯示器）

        last_score_time = current_time  # 更新上次得分時間

    # 根據按鍵控制輪子移動方向
    if key == ord('S') or key == ord('w'):
        # 前進
        velocity = MAX_VELOCITY
        set_wheel_velocity(velocity, velocity, velocity, velocity)
    elif key == ord('W') or key == ord('s'):
        # 後退
        velocity = -MAX_VELOCITY
        set_wheel_velocity(velocity, velocity, velocity, velocity)
    elif key == ord('D') or key == ord('d'):
        # 右轉：左輪前進，右輪後退
        velocity = MAX_VELOCITY
        set_wheel_velocity(-velocity, velocity, -velocity, velocity)
    elif key == ord('A') or key == ord('a'):
        # 左轉：左輪後退，右輪前進
        velocity = MAX_VELOCITY
        set_wheel_velocity(velocity, -velocity, velocity, -velocity)
    elif key == ord('Q') or key == ord('q'):
        # 離開程式
        print("Exiting...")
        break
    else:
        # 沒有按鍵時停止移動
        set_wheel_velocity(0, 0, 0, 0)
</pre>
<p><span></span></p>
<p><span>我將原本控制第二台車的按鍵EDSX 改成遊戲常用的WDAS，這樣是能讓移動上更加直覺。</span></p>
<h2>counter supervisor</h2>
<p></p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">from controller import Supervisor

# 七段顯示器每個數字對應的亮燈狀態（a-g段）
SEGMENTS = [
    [1,1,1,1,1,1,0], # 0
    [0,1,1,0,0,0,0], # 1
    [1,1,0,1,1,0,1], # 2
    [1,1,1,1,0,0,1], # 3
    [0,1,1,0,0,1,1], # 4
    [1,0,1,1,0,1,1], # 5
    [1,0,1,1,1,1,1], # 6
    [1,1,1,0,0,0,0], # 7
    [1,1,1,1,1,1,1], # 8
    [1,1,1,1,0,1,1], # 9
]

# 各個數字位數（百、十、個）對應的材質名稱（a-g 段）
DIGIT_MATERIALS = [
    ['a3mat', 'b3mat', 'c3mat', 'd3mat', 'e3mat', 'f3mat', 'g3mat'], # 百位
    ['a2mat', 'b2mat', 'c2mat', 'd2mat', 'e2mat', 'f2mat', 'g2mat'], # 十位
    ['a1mat', 'b1mat', 'c1mat', 'd1mat', 'e1mat', 'f1mat', 'g1mat'], # 個位
]

# 定義亮燈的顏色 (綠色)
ON_COLOR = [0, 1, 0]

# 定義熄燈的顏色 (深灰)
OFF_COLOR = [0.05, 0.05, 0.05]

# 設定某一個位數的顯示數字
def set_digit(supervisor, digit_index, value):
    segs = SEGMENTS[value]  # 取得該數字對應的七段顯示狀態
    for i, seg_on in enumerate(segs):
        # 根據 digit_index 取得該段的材質節點
        mat_node = supervisor.getFromDef(DIGIT_MATERIALS[digit_index][i])
        if mat_node:
            # 設定段的顏色：亮或暗
            mat_node.getField('diffuseColor').setSFColor(ON_COLOR if seg_on else OFF_COLOR)
        else:
            print(f"找不到 {DIGIT_MATERIALS[digit_index][i]} 這個DEF")  # 找不到對應 DEF 時輸出錯誤

# 設定整個顯示器顯示的數字（最多 3 位數）
def set_display(supervisor, value):
    value = max(0, min(999, int(value)))  # 限制數值在 0~999 範圍
    h = value // 100                     # 百位
    t = (value // 10) % 10               # 十位
    u = value % 10                       # 個位
    set_digit(supervisor, 0, h)          # 設定百位數字
    set_digit(supervisor, 1, t)          # 設定十位數字
    set_digit(supervisor, 2, u)          # 設定個位數字

# 建立 Supervisor 實例
supervisor = Supervisor()

# 取得 Webots 中設定的基本時間步長
timestep = int(supervisor.getBasicTimeStep())

# 初始分數為 0
score = 0

# 取得名為 "score_receiver" 的裝置（接收分數訊息）
receiver = supervisor.getDevice("score_receiver")
receiver.enable(timestep)  # 啟用接收器，並以 timestep 為更新間隔

# 主迴圈，每個時間步執行一次
while supervisor.step(timestep) != -1:
    # 當接收器中有資料時
    while receiver.getQueueLength() &gt; 0:
        data = receiver.getString()  # 取得接收到的字串資料
        if data.isdigit():           # 檢查是否是數字字串
            try:
                received_score = int(data)  # 將字串轉成整數
                score += received_score     # 累加到總分
                print(f"收到得分訊息: +{received_score}, 總分: {score}")  # 印出訊息
            except Exception as e:
                print("訊息格式錯誤:", e)  # 如果轉換錯誤，顯示錯誤訊息
        receiver.nextPacket()  # 移至下一筆封包
    set_display(supervisor, score)  # 更新七段顯示器的分數顯示
</pre>
<p></p>
<p></p>
<h1>Brython</h1>
<p><button id="add1to100">1 add to 100</button></p>
<!-- 導入 brython 程式庫 -->
<p>
<script src="/static/brython.js"></script>
<script src="/static/brython_stdlib.js"></script>
</p>
<!-- 啟動 Brython -->
<p>
<script>
window.onload=function(){
brython({debug:1, pythonpath:['/static/','./../downloads/py/']});
}
</script>
</p>
<p><!-- 導入 FileSaver 與 filereader --></p>
<p>
<script src="/static/ace/FileSaver.min.js" type="text/javascript"></script>
<script src="/static/ace/filereader.js" type="text/javascript"></script>
</p>
<p><!-- 導入 ace --></p>
<p>
<script src="/static/ace/ace.js" type="text/javascript"></script>
<script src="/static/ace/ext-language_tools.js" type="text/javascript"></script>
<script src="/static/ace/mode-python3.js" type="text/javascript"></script>
<script src="/static/ace/snippets/python.js" type="text/javascript"></script>
</p>
<p><!-- 導入 gearUtils-0.9.js Cango 齒輪繪圖程式庫 -->
<script src="/static/Cango-24v03-min.js"></script>
<script src="/static/gearUtils-09.js"></script>
<script src="/static/SVGpathUtils-6v03-min.js"></script>
<script src="/static/sylvester.js"></script>
<script src="/static/PrairieDraw.js"></script>
</p>
<p><!-- 請注意, 這裡使用 Javascript 將 localStorage["kw_py_src1"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱--></p>
<p>
<script type="text/javascript">
function doSave(storage_id, filename){
    var blob = new Blob([localStorage[storage_id]], {type: "text/plain;charset=utf-8"});
    filename = document.getElementById(filename).value
    saveAs(blob, filename+".py");
}
</script>
</p>
<p>
<script type="text/python3">
from browser import document as doc
import ace
# 清除畫布
def clear_bd1(ev):
    bd = doc["brython_div1"]
    bd.clear()
Ace1 = ace.Editor(editor_id="kw_editor1", console_id="kw_console1", container_id="kw__container1", storage_id="kw_py_src1" )
# 從 gist 取出程式碼後, 放入 editor 作為 default 程式
def run1():
    # 利用 get 取下 src 變數值
    try:
        url = doc.query["src"]
    except:
        url = "https://gist.githubusercontent.com/mdecourse/0229a8a017091476a79700b8a190f185/raw/c3a6deaf717f8f2739a4b1392a5ab10936e9693a/from_1_add_to_10_1.py"
    prog = open(url).read()

    # 將程式載入編輯區
    Ace1.editor.setValue(prog)
    Ace1.editor.scrollToRow(0)
    Ace1.editor.gotoLine(0)
    # 直接執行程式
    #ns = {'__name__':'__main__'}
    #exec(prog, ns)
    # 按下 run 按鈕
    Ace1.run()

# 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定
doc['kw_run1'].bind('click', Ace1.run)
doc['kw_show_console1'].bind('click', Ace1.show_console)
doc['kw_clear_console1'].bind('click', Ace1.clear_console)
doc['clear_bd1'].bind('click', clear_bd1)
# 呼叫函式執行
run1()
</script>
</p>
<p><!-- add 1 to 100 開始 -->
<script type="text/python3">
from browser import document as doc
import ace

# 清除畫布
def clear_bd1(ev):
    bd = doc["brython_div1"]
    bd.clear()

# 利用 ace 中的 Editor 建立 Ace2 物件, 其中的輸入變數分別對應到頁面中的編輯區物件
Ace2 = ace.Editor(editor_id="kw_editor1", console_id="kw_console1", container_id="kw__container1", storage_id="kw_py_src1" )

add1to100_url = "https://gist.githubusercontent.com/mdecourse/0229a8a017091476a79700b8a190f185/raw/c48e37714f055c3a0027cbfef59e442a6ef659b9/from_1_add_to_100_1.py"

# 從 gist 取得程式碼
add_src = open(add1to100_url).read()
def add(ev):
    Ace2.editor.setValue(add_src)
    Ace2.editor.scrollToRow(0)
    Ace2.editor.gotoLine(0)
    Ace2.run()

# id 為 "add1to100" 的按鈕點按時, 執行 add 方法
doc["add1to100"].bind('click', add)
</script>
</p>
<p><!-- add 1 to 100 結束--></p>
<!-- editor1 開始 -->
<p><!-- 用來顯示程式碼的 editor 區域 --></p>
<div id="kw_editor1" style="width: 600px; height: 300px;"></div>
<p><!-- 以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合 --></p>
<p><!-- 存擋表單開始 --></p>
<form><label>Filename: <input id="kw_filename" placeholder="input file name" type="text"/>.py</label> <input onclick="doSave('kw_py_src1', 'kw_filename1');" type="submit" value="Save"/></form>
<p><!-- 存擋表單結束 --></p>
<p></p>
<p><!-- 執行與清除按鈕開始 --></p>
<p><button id="kw_run1">Run</button> <button id="kw_show_console1">Output</button> <button id="kw_clear_console1">清除輸出區</button><button id="clear_bd1">清除繪圖區</button><button onclick="window.location.reload()">Reload</button></p>
<p><!-- 執行與清除按鈕結束 --></p>
<p></p>
<p><!-- 程式執行 ouput 區 --></p>
<div style="width: 100%; height: 100%;"><textarea autocomplete="off" id="kw_console1"></textarea></div>
<p><!-- Brython 程式執行的結果, 都以 brython_div1 作為切入位置 --></p>
<div id="brython_div1"></div>
<!-- editor1 結束 --><hr/><!-- ########################################## -->
<p>從 1 累加到 100 part2:</p>
<p><button id="add1to100part2">1 add to 100</button><button id="cango_three_gears">cango_three_gears</button><button id="bsnake">BSnake</button><button id="aitetris">AI Tetris</button></p>
<p><!-- 請注意, 這裡使用 Javascript 將 localStorage["kw_py_src2"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱--></p>
<p>
<script type="text/python3">
from browser import document as doc
import ace
# 清除畫布
def clear_bd2(ev):
    bd = doc["brython_div2"]
    bd.clear()
Ace3 = ace.Editor(editor_id="kw_editor2", console_id="kw_console2", container_id="kw__container2", storage_id="kw_py_src2" )
# 從 gist 取出程式碼後, 放入 editor 作為 default 程式
def run2():
    # 利用 get 取下 src 變數值
    try:
        url = doc.query["src2"]
    except:
        url = "https://gist.githubusercontent.com/mdecourse/0229a8a017091476a79700b8a190f185/raw/c3a6deaf717f8f2739a4b1392a5ab10936e9693a/from_1_add_to_10_1.py"
    prog = open(url).read()

    # 將程式載入編輯區
    Ace3.editor.setValue(prog)
    Ace3.editor.scrollToRow(0)
    Ace3.editor.gotoLine(0)
    # 直接執行程式
    #ns = {'__name__':'__main__'}
    #exec(prog, ns)
    # 按下 run 按鈕
    Ace3.run()

# 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定
doc['kw_run2'].bind('click', Ace3.run)
doc['kw_show_console2'].bind('click', Ace3.show_console)
doc['kw_clear_console2'].bind('click', Ace3.clear_console)
doc['clear_bd2'].bind('click', clear_bd2)
# 呼叫函式執行
run2()
</script>
</p>
<p><!-- add 1 to 100 part2 開始 -->
<script type="text/python3">
from browser import document as doc
import ace

# 清除畫布
def clear_bd2(ev):
    bd = doc["brython_div2"]
    bd.clear()

# 利用 ace 中的 Editor 建立 Ace2 物件, 其中的輸入變數分別對應到頁面中的編輯區物件
Ace4 = ace.Editor(editor_id="kw_editor2", console_id="kw_console2", container_id="kw__container2", storage_id="kw_py_src2" )

# 透過 Ace4 以類別建立一個通用的 button2, 可以在多個案例中將 gist 程導入編輯區

class button2:
    def __init__(self, url):
        self.url = url

    # 記得加入 event 輸入變數
    def do(self,ev):
        Ace4.editor.setValue(open(self.url).read())
        Ace4.editor.scrollToRow(0)
        Ace4.editor.gotoLine(0)
        Ace4.run()

add1to100_url = "https://gist.githubusercontent.com/mdecourse/0229a8a017091476a79700b8a190f185/raw/c48e37714f055c3a0027cbfef59e442a6ef659b9/from_1_add_to_100_1.py"

# 從 gist 取得程式碼
add_src = open(add1to100_url).read()
def add2(ev):
    Ace4.editor.setValue(add_src)
    Ace4.editor.scrollToRow(0)
    Ace4.editor.gotoLine(0)
    Ace4.run()

# id 為 "add1to100part2" 的按鈕點按時, 執行 add 方法
doc["add1to100part2"].bind('click', add2)
# 以下為運用 button2 class 的通用 gist 程式導入區
################################## cango_three_gears start
cango_three_gears_url = "https://gist.githubusercontent.com/mdecycu/d9082d678096bd58378d6afe2c7fa05d/raw/f7a85d737d6723d5e34c526d5daee990ed92c32b/cango_three_gears_brython_div2.py"
cango_three_gears = button2(cango_three_gears_url)
doc["cango_three_gears"].bind("click", cango_three_gears.do)
################################## cango_three_gears end
################################## bsnake start
bsnake_url = "https://gist.githubusercontent.com/mdecycu/d9082d678096bd58378d6afe2c7fa05d/raw/f7a85d737d6723d5e34c526d5daee990ed92c32b/kmol_snakey.py"
bsnake = button2(bsnake_url)
doc["bsnake"].bind("click", bsnake.do)
################################## bsnake end
################################## aitetris start
aitetris_url = "https://gist.githubusercontent.com/mdecycu/d9082d678096bd58378d6afe2c7fa05d/raw/f7a85d737d6723d5e34c526d5daee990ed92c32b/pygame_to_brython_tetris_ai.py"
aitetris = button2(aitetris_url)
doc["aitetris"].bind("click", aitetris.do)
################################## aitetris end
</script>
</p>
<p><!-- add 1 to 100 part2 結束--></p>
<!-- editor2 開始 -->
<p><!-- 用來顯示程式碼的 editor 區域 --></p>
<div id="kw_editor2" style="width: 600px; height: 300px;"></div>
<p><!-- 以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合 --></p>
<p><!-- 存擋表單開始 --></p>
<form><label>Filename: <input id="kw_filename2" placeholder="input file name" type="text"/>.py</label> <input onclick="doSave('kw_py_src2', 'kw_filename2');" type="submit" value="Save"/></form>
<p><!-- 存擋表單結束 --></p>
<p></p>
<p><!-- 執行與清除按鈕開始 --></p>
<p><button id="kw_run2">Run</button> <button id="kw_show_console2">Output</button> <button id="kw_clear_console2">清除輸出區</button><button id="clear_bd2">清除繪圖區</button><button onclick="window.location.reload()">Reload</button></p>
<p><!-- 執行與清除按鈕結束 --></p>
<p></p>
<p><!-- 程式執行 ouput 區 --></p>
<div style="width: 100%; height: 100%;"><textarea autocomplete="off" id="kw_console2"></textarea></div>
<p><!-- Brython 程式執行的結果, 都以 brython_div1 作為切入位置 --></p>
<div id="brython_div2"></div>
<!-- editor2 結束 --><hr/>
<p>
<script src="https://unpkg.com/three@0.144.0/build/three.js" type="text/javascript"></script>
</p>