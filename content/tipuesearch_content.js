var tipuesearch = {"pages": [{'title': 'About', 'text': '課程名稱: 協同產品設計實習 - Collaborative Product Design Practice \n 學員作業網站:\xa0 https://mdecd2025.github.io/hw-41223230/ \n 學員作業倉儲:\xa0https://github.com/mdecd2025/hw-41223230 \n \n 課程代號: cd2025 \n Teams 線上教學: \n 以 "學號@nfu.edu.tw" 登入 \xa0 https://login.microsoftonline.com/ \xa0 Office 365 \n Teams 團隊代碼:\xa0 p5z4eku \n \n 課程評分: \n Homework (30%) - 每週至少提交兩次與課程進度有關的內容, 完成後填回自評表單 \n Exam (40%) - 建立包含操作流程影片、心得以及提供檔案下載的網頁後填回自評表單 \n Final Report (30%) - 利用網頁內容進行簡報並提交 pdf 格式書面報告, 完成後填回自評表單 \n', 'tags': '', 'url': 'About.html'}, {'title': 'repo', 'text': '', 'tags': '', 'url': 'repo.html'}, {'title': 'Tasks', 'text': '', 'tags': '', 'url': 'Tasks.html'}, {'title': 'task1', 'text': '將上學期舊版的python 311 更改為python 313，以利之後使用 新版的 SciTE, Portablegit, PUTTY, ShareX, Wink 以及原有的 tmp 及 home_ipv6, 以另存新的 \xa0start.bat \xa0 啟動 \n \n', 'tags': '', 'url': 'task1.html'}, {'title': 'list', 'text': 'from browser import html, document, ajax  # 從 Brython 的 browser 模組匯入 html、document 和 ajax，方便操作 DOM 和發送請求\n\nurl = "https://mde.tw/list/2b.txt"  # 要讀取的文字檔網址（學員清單）\n\n# 定義當 AJAX 請求完成時要執行的函式\ndef on_complete(req):\n    if req.status == 200:  # 如果請求成功（狀態碼 200）\n        data = req.text.splitlines()  # 取得文字內容並按行分割成清單\n        all_stud = data[1:]  # 去除第一行標題，只保留學生資料\n\n        # 建立一個無序清單 (UL) 元素\n        stud_list = html.UL()\n\n        # 逐行處理每位學生的資料\n        for stud in all_stud:\n            fields = stud.split()  # 假設每行資料用空白分隔，將其分割成清單\n            if len(fields) >= 2:  # 確保至少有兩個欄位（學號和帳號）\n                stud_id, account = fields[:2]  # 取得學號與帳號\n                link = f"https://github.com/mde2025/hw-{stud_id}"  # 組合 GitHub 作業連結\n\n                # 創建一個清單項目 (LI)，包含帳號和超連結\n                stud_list <= html.LI([\n                    f"{account} - ",  # 顯示帳號\n                    html.A(link, href=link, target="_blank")  # 超連結指向 GitHub 作業頁面，另開新視窗\n                ])\n\n        # 將總人數與名單插入至網頁指定區塊中\n        document["brython_div1"] <= html.P(f"總共有 {len(all_stud)} 名學員")  # 顯示總人數\n        document["brython_div1"] <= stud_list  # 顯示整個清單\n\n    else:\n        # 若請求失敗，顯示錯誤訊息\n        document["brython_div1"] <= html.P("無法取得資料")\n\n# 發送 AJAX 請求，並設定完成後執行的函式\najax.get(url, oncomplete=on_complete)\n \n \n 執行名單(64位學員) \n \n \n a40923137 - \xa0 https://github.com/mde2025/hw-40923137 \n 41023114 - \xa0 https://github.com/mde2025/hw-41023114 \n c-ching - \xa0 https://github.com/mde2025/hw-41023205 \n tseYU000 - \xa0 https://github.com/mde2025/hw-41023206 \n junpig10 - \xa0 https://github.com/mde2025/hw-41023210 \n 41023213 - \xa0 https://github.com/mde2025/hw-41023213 \n 41023215 - \xa0 https://github.com/mde2025/hw-41023215 \n 41023216 - \xa0 https://github.com/mde2025/hw-41023216 \n snowfall-killer - \xa0 https://github.com/mde2025/hw-41023218 \n YUN4 - \xa0 https://github.com/mde2025/hw-41023232 \n www000123 - \xa0 https://github.com/mde2025/hw-41023237 \n 41071202 - \xa0 https://github.com/mde2025/hw-41071202 \n 41071203 - \xa0 https://github.com/mde2025/hw-41071203 \n 41071204 - \xa0 https://github.com/mde2025/hw-41071204 \n 41223201 - \xa0 https://github.com/mde2025/hw-41223201 \n 41223202 - \xa0 https://github.com/mde2025/hw-41223202 \n 41223203 - \xa0 https://github.com/mde2025/hw-41223203 \n 41223205 - \xa0 https://github.com/mde2025/hw-41223205 \n 41223206 - \xa0 https://github.com/mde2025/hw-41223206 \n emma0312 - \xa0 https://github.com/mde2025/hw-41223207 \n 41223208-hw - \xa0 https://github.com/mde2025/hw-41223208 \n 41223209 - \xa0 https://github.com/mde2025/hw-41223209 \n 41223211 - \xa0 https://github.com/mde2025/hw-41223211 \n jjjay41223212 - \xa0 https://github.com/mde2025/hw-41223212 \n RAY41223215 - \xa0 https://github.com/mde2025/hw-41223215 \n 41223216 - \xa0 https://github.com/mde2025/hw-41223216 \n 41223217 - \xa0 https://github.com/mde2025/hw-41223217 \n 41223218 - \xa0 https://github.com/mde2025/hw-41223218 \n 41223219 - \xa0 https://github.com/mde2025/hw-41223219 \n ljg41223220 - \xa0 https://github.com/mde2025/hw-41223220 \n leeshaowei0716 - \xa0 https://github.com/mde2025/hw-41223221 \n 41223222 - \xa0 https://github.com/mde2025/hw-41223222 \n linryan23 - \xa0 https://github.com/mde2025/hw-41223223 \n 41223224 - \xa0 https://github.com/mde2025/hw-41223224 \n 41223225 - \xa0 https://github.com/mde2025/hw-41223225 \n 41223226-0 - \xa0 https://github.com/mde2025/hw-41223226 \n 41223227 - \xa0 https://github.com/mde2025/hw-41223227 \n hyy41223228 - \xa0 https://github.com/mde2025/hw-41223228 \n 41223229 - \xa0 https://github.com/mde2025/hw-41223229 \n 41223230 - \xa0 https://github.com/mde2025/hw-41223230 \n 41223231 - \xa0 https://github.com/mde2025/hw-41223231 \n 41223232 - \xa0 https://github.com/mde2025/hw-41223232 \n 41223233even - \xa0 https://github.com/mde2025/hw-41223233 \n 41223234 - \xa0 https://github.com/mde2025/hw-41223234 \n 41223235 - \xa0 https://github.com/mde2025/hw-41223235 \n 41223236 - \xa0 https://github.com/mde2025/hw-41223236 \n Cloud41223237 - \xa0 https://github.com/mde2025/hw-41223237 \n WeihHuang - \xa0 https://github.com/mde2025/hw-41223239 \n ych0227 - \xa0 https://github.com/mde2025/hw-41223240 \n 41223242 - \xa0 https://github.com/mde2025/hw-41223242 \n 41223243 - \xa0 https://github.com/mde2025/hw-41223243 \n Liu41223244 - \xa0 https://github.com/mde2025/hw-41223244 \n 41223245 - \xa0 https://github.com/mde2025/hw-41223245 \n 41223246 - \xa0 https://github.com/mde2025/hw-41223246 \n CYC41223247 - \xa0 https://github.com/mde2025/hw-41223247 \n 41223248 - \xa0 https://github.com/mde2025/hw-41223248 \n 41223249 - \xa0 https://github.com/mde2025/hw-41223249 \n timluo123 - \xa0 https://github.com/mde2025/hw-41223250 \n 41223251 - \xa0 https://github.com/mde2025/hw-41223251 \n supowen - \xa0 https://github.com/mde2025/hw-41223252 \n jacky93111 - \xa0 https://github.com/mde2025/hw-41223253 \n 41271237 - \xa0 https://github.com/mde2025/hw-41271237 \n \n \n \n \n \n', 'tags': '', 'url': 'list.html'}, {'title': 'task2', 'text': 'from browser import html, document, ajax  # 從 Brython 的 browser 模組匯入 html、document 和 ajax，用來操作網頁和發送請求\n\nurl = "https://mde.tw/list/2b.txt"  # 存放學生清單的純文字檔案網址\n\n# G7 組員的學號集合，用 set 儲存，方便快速查詢是否為組員\ng7_members = {"41023114", "41223218", "41223230", "41223247", "41223250", "41223240"}\n\n# 定義當 AJAX 請求完成後要執行的函式\ndef on_complete(req):\n    if req.status == 200:  # 如果伺服器回應狀態碼是 200（表示成功）\n        data = req.text.splitlines()  # 將收到的純文字內容按行分割成列表\n        all_stud = data[1:]  # 跳過第一行標題，取得所有學生資料\n\n        # 建立一個無序清單 (UL) HTML 元素，用來放組員資料\n        stud_list = html.UL()\n\n        # 遍歷每一筆學生資料\n        for stud in all_stud:\n            fields = stud.split()  # 將每一行用空白切割，預期會得到 [學號, 帳號]\n            if len(fields) >= 2:  # 確保至少有學號和帳號兩欄\n                stud_id, account = fields[:2]  # 取得學號和帳號\n\n                # 如果這位學生是 G7 組員\n                if stud_id in g7_members:\n                    link = f"https://mdecd2025.github.io/hw-{stud_id}"  # 組合作業連結（對應 GitHub Pages）\n                    \n                    # 建立一個清單項目 (LI)，顯示帳號和超連結\n                    stud_list <= html.LI([\n                        f"{account} - ",  # 顯示帳號\n                        html.A(link, href=link, target="_blank")  # 加入一個可點擊的超連結，另開新分頁\n                    ])\n\n        # 把資訊插入到 HTML 中 id 為 brython_div1 的區塊\n        document["brython_div1"] <= html.P(f"G7 組員 ({len(g7_members)} 名)：")  # 顯示組員總數\n        document["brython_div1"] <= stud_list  # 顯示組員清單\n\n    else:\n        # 如果 AJAX 請求失敗（非 200 回應），顯示錯誤訊息\n        document["brython_div1"] <= html.P("無法取得資料")\n\n# 使用 ajax.get 送出 GET 請求，完成後呼叫 on_complete 函式\najax.get(url, oncomplete=on_complete)\n \n G7執行結果 \n 小組成員名單 \n \n 41023114 - \xa0 https://mdecd2025.github.io/hw-41023114 \n 41223218 - \xa0 https://mdecd2025.github.io/hw-41223218 \n 41223230 - \xa0 https://mdecd2025.github.io/hw-41223230 \n ych0227 - \xa0 https://mdecd2025.github.io/hw-41223240 \n CYC41223247 - \xa0 https://mdecd2025.github.io/hw-41223247 \n timluo123 - \xa0 https://mdecd2025.github.io/hw-41223250 \n \n \n \n', 'tags': '', 'url': 'task2.html'}, {'title': 'task3', 'text': '', 'tags': '', 'url': 'task3.html'}, {'title': 'task4', 'text': 'base slvs.zip \n base stl.zip \n \n \n link_1 slvs.zip \n link_1 stl.zip \n \n \n link_2 slvs.zip \n link_2 stl.zip \n \n \n link_3 slvs.zip \n link_3 stl.zip \n \n \n shaft_1 slvs.zip \n shaft_1 stl.zip \n \n \n shaft_2 slvs.zip \n shaft_2 stl.zip \n \n \n fourbar design.zip \n \n \n fourbar_assemble.zip \n \n', 'tags': '', 'url': 'task4.html'}, {'title': 'task5', 'text': 'ball.7z \n \n \n base plate.7z \n \n \n connected board.7z \n \n \n press board.7z \n \n \n shaft.7z \n \n \n shaft1.7z \n \n \n shaft2.7z \n \n \n shaft3.7z \n \n \n shaft4.7z \n \n \n shoot board.7z \n \n \n shoot design.7z \n \n \n shooter assembly.zip \n \n \n \n \n \n \n \n', 'tags': '', 'url': 'task5.html'}, {'title': 'task6', 'text': '', 'tags': '', 'url': 'task6.html'}, {'title': 'Homework', 'text': '作業 (30%) \n HW1 (5%):  建立由 Box 組成的平面四連桿機構 Webots 模擬場景 \n part1: \n 請各學員在 USB 隨身碟或個人電腦上完成 cd2025 課程所需的可攜系統配置: \n 下載  portable_wcm2025.7z  (330MB, 解開壓縮後 1.4GB) \n Webots_2025a.7z  (1.5 GB, 解開後約為 2.9GB, 可單獨運作) \n Webots_2025a_web.7z  (171 MB, 解開壓縮後約為 1GB, 必須連網運作) \n Blender4.2.7z \n part2: \n 請各學員完成可攜程式系統配置後, 利用 Webots R2025a 中寬度與高度都為 0.1m 的 box 物件建立一個簡單的平面四連桿機構模擬場景. \n base (基座) 長度 1m, link1 長度 0.4m, link2 長度 0.6m, link3 長度 0.9m, 各轉軸均為 HingeJoint, joint1 旋轉速度設定為 1radian/sec. \n part3: \n 模擬場景啟動後, 按下 s 鍵機構開始作動, 按下 p 鍵後機構暫停. \n 參考資料: \n cd2025_hw1_demo.7z \n HW2 (5%):  建立由 CAD 繪製零件組成的平面四連桿機構 Webots 模擬場景 \n 各學員請利用 CAD 系統依據 HW1 的連桿尺寸與運動方式, 配置適當大小的旋轉軸以及基座後, 利用 Webots R2025a 完成一個簡單的平面四連桿機構模擬場景. \n 參考資料: \n fourbar_slvs.7z \n HW3 (20%): 建立 Webots 桌上籃球遊戲機模擬系統 \n 請各分組利用CAD 系統建立一個能在電腦桌 (1600W X 700D X 740H mm) 上運作的投籃機構 ( 參考影片 )後, 導入 Webots R2025a 套件, 建立一個能由使用者透過鍵盤按鍵操作, 且具備計分板的籃球遊戲機模擬系統. \n 參考資料: \n 參考資料: \n fourbar_ball_throwing_linkage.slvs \n sixbar_ball_throwing_linkage.slvs \n \n', 'tags': '', 'url': 'Homework.html'}, {'title': 'HW1', 'text': '\n \n fourbar webots.7z \n 操作流程 \n 一開始先建一個 robot，然後在它的 children 裡加兩個 hinge joint 跟一個 solid。 \n solid 的部分我會把它改名叫做 base，然後在它的 children 裡右鍵新增一個 shape，進到 geometry 裡右鍵新增一個 box，然後把 X 的尺寸設成 1 公尺。 \n （之後就不再重複說明怎麼加 box 的步驟了。） \n 接著從兩個 hinge joint 任選一個，把它改名成 hinge joint1，另一個就叫 hinge joint4。 \n 接下來點進 hinge joint1，在它的主線程下面，找到 endpoint，右鍵新增一個 solid，然後調整一下它的數值。rotation 的部分可以自己設定，當作是初始角度。 \n 在這個 solid 的 children 裡面，再加一個 pose 跟一個 hinge joint，然後把這個 hinge joint 命名為 joint2。 \n 然後 joint2 的處理方式跟剛剛 joint1 一樣：在 children 裡面新增一個 solid，接著加 pose（放在 box 的中心位置），再加一個 hinge joint，把它命名為 joint3，然後建立第三個 box。 \n 這樣 box 的結構就完成了，接下來要來設定 jointParameters。 \n jointParameters 的重點是在設定關節相對於原點（0,0,0）的座標位置。舉例來說，如果 link1 的座標相對於原點是往負 X 移動 0.5 公尺，那 anchor 的 X 值就要設成 -0.5m。link2 跟 link3 的設法也是一樣的邏輯。 \n 然後在 joint1 上加一個旋轉馬達，命名為 motor（這會用在後面的控制程式裡）。 \n 最後一個步驟是幫 link1、link2、link3 建立 boundingObject，這個是用來定義物體的物理碰撞範圍的。 \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n fourbar_controller.7z \n from controller import Robot  # 從 Webots 控制器模組匯入 Robot 類別\n\ndef run_robot():\n    # 建立 Robot 實例\n    robot = Robot()\n\n    # 獲取模擬的基本時間步長 (單位：毫秒)\n    timestep = int(robot.getBasicTimeStep())\n\n    # 取得名為 \'motor\' 的馬達裝置\n    motor = robot.getDevice(\'motor\')\n\n    # 設定馬達為無限旋轉模式（連續轉動，不是轉到特定角度）\n    motor.setPosition(float(\'inf\'))\n\n    # 設定馬達旋轉速度為 1.0 弧度/秒\n    motor.setVelocity(1.0)\n\n    # 主控制迴圈：只要模擬沒結束，就一直執行\n    while robot.step(timestep) != -1:\n        pass  # 目前不需要在每個時間步做額外的動作\n\n# 如果此檔案是直接執行的，呼叫 run_robot() 函式\nif __name__ == "__main__":\n    run_robot()\n \n \n 心得：這是第一次使用webots，過程當中遇到超多問題，一開始是如何做設置、模擬程式導入許多問題，好險問同學之後慢慢地學會使用。 \n \n HW1 (5%):  建立由 Box 組成的平面四連桿機構 Webots 模擬場景 \n 操作影片標題: 國立虎尾科技大學 - 機械設計工程系 - cd2025 HW1 - 學員學號 \n', 'tags': '', 'url': 'HW1.html'}, {'title': 'HW2', 'text': '繪製檔案轉obj \n 檔案： fourbar obj \n \n \n 作業檔案： fourbar webots.7z \n \n 作業流程 \n 在solvespace繪製零件並將組裝好整個機構之後，先把檔案存起來，接著輸出一個 .stl 檔。 \n 然後用 split_stl_to_obj_scale2 這個工具把 .stl 轉成 .obj \n 接下來進入 Webots後，先在場景裡加入一個 Robot 群組。 \n 在這個 Robot 裡的 children 加入兩個 Solid 當作是base，再加兩個 HingeJoint，其中一個命名成 joint1，另一個是 joint4。 \n ，再接下來的操作和 HW1 差不多，差別在於HW1的 box是用內建，而這次不是用內建的，而是使用自己在solvespace畫好的模型匯入。要將檔案匯入有兩種方式：第一個是用 CadShape 匯入 .obj，第二個是用 Shape -> Mesh 來匯入。而我選擇Shape -> Mesh，這樣比較方便調整顏色。 \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n 心得：這次作業是使用自己所畫的圖檔，導入webots做使用，在這之前需要先將檔案會成obj，一開始我是使用 solvespace直接匯出導入webots後，發現變超級大的，原來webots所使用的單位是m公尺，所以我們所繪製的圖與變成了m公尺，後來才得知是需要使用split_stl_to_obj_scale2 這個工具，轉出轉換單位的obj才得以解決。 \n HW2 (5%):  建立由 CAD 繪製零件組成的平面四連桿機構 Webots 模擬場景 \n 操作影片標題: 國立虎尾科技大學 - 機械設計工程系 - cd2025 HW2 - 學員學號 \n', 'tags': '', 'url': 'HW2.html'}, {'title': 'HW3', 'text': '\n \n 作業檔案： basketball shoot webots.zip \n \n 作業流程 \n \n 本次作業和HW2流程一樣，需要先將圖檔繪製好組裝好，並將檔案匯出成.obj，再進到webots做組裝，而這次比較特別別的是有增加一顆球和籃框，目標是要將開啟模擬時可以將球投入籃框。 \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n 心得：這次的作業做起來相對於之前兩次順手，這次一樣是要先繪製、轉檔案再進入webots做操作，這次比較特別的就是多加了籃框和一顆球，而球的部分我一開始以為是要自己繪製，但後來再做設置的時候感覺怪怪的，詢問同學後才知道內建就有球體可做使用，害我還花時間去畫一顆球轉檔來用。 \n \n 作業檔案： basketball hoop webots.7z \n # 從 Webots 的 controller 模組中導入 Robot 類別\nfrom controller import Robot\n\n# 定義主函式\ndef run_robot():\n    # 建立一個 Robot 實例，用來與模擬中的機器人互動\n    robot = Robot()\n\n    # 取得模擬的基本時間步長（以毫秒為單位）\n    timestep = int(robot.getBasicTimeStep())\n\n    # 取得名為 \'motor1\' 的馬達裝置\n    motor = robot.getDevice(\'motor1\')\n\n    # 取得鍵盤裝置，並啟用以便後續讀取輸入\n    keyboard = robot.getKeyboard()\n    keyboard.enable(timestep)  # 啟用鍵盤裝置，並設定掃描間隔為 timestep\n\n    # 設定馬達的初始位置（此處未實際使用，但可作為預設值）\n    initial_position = 0.0  # 假設初始位置為 0 弧度\n\n    # 主要控制迴圈，每次迴圈會根據 timestep 推進模擬\n    while robot.step(timestep) != -1:\n        # 將馬達的位置設定為 38 度（轉換為弧度後設為目標位置）\n        motor.setPosition(38 * 3.14159 / 180)\n\n# 如果這個程式是主程式執行，則呼叫主函式\nif __name__ == "__main__":\n    run_robot()\n \n \n 作業檔案： basketball shoot webots.zip \n HW3 (20%): 建立 Webots 桌上籃球遊戲機模擬系統 \n 操作影片標題: 國立虎尾科技大學 - 機械設計工程系 - cd2025 HW3 - 學員學號 \n', 'tags': '', 'url': 'HW3.html'}, {'title': 'Midterm', 'text': '各週進度: 可攜更改python 313、學員名單、小組名單、四連桿繪製組裝 \n 各週網頁內容: task1 、 task1 list 、 task2 、 task4 \n 期中心得:上完九週的課程，個人覺得這門課比上一門課困難許多，而且目前作業進度落後，需要多加跟上。 \n 期中自評影片 \n \n \n \n', 'tags': '', 'url': 'Midterm.html'}, {'title': 'Exam', 'text': 'Exam1 (10%): 建立 Webots 基本物件模擬場景 \n 各學員利用 Webots R2025a 套件中的 Shape 物件, 隨堂建立指定的機電系統模擬場景, 並利用 Python 程式進行互動控制. \n Exam2 (10%): 利用 CAD 零組件建立模擬場景\xa0 \n 各學員利用 CAD (Solvespace 與 NX2312), 隨堂建立指定的系統模型零組件後, 導入 Webots R2025a 後, 建立機電系統模擬場景, 並利用 Python 程式進行互動控制. \n Exam3 (20%): Webots 機電模擬場景的協同設計 \n 各分組利用 CAD (Solvespace 與 NX2312), 隨堂建立指定的系統模型零組件後, 導入 Webots R2025a 後, 建立機電系統模擬場景, 並利用 Python 程式進行互動控制. 過程中各學員必須採同步協同模式, 維護從 Github Classroom 取得的分組協同倉儲以及網站. \n 協同分組方式: \n \n 分配學員負責利用 Solvespace 建立系統零組件, 過程中必須將所建構之零組件檔案與繪圖過程影片上傳至分組網頁. \n 分配學員負責利用 NX2312 建立系統零組件, 過程中必須將所建構之零組件檔案與繪圖過程影片上傳至分組網頁. \n 分配學員負責利用 Webots 建立機電系統模擬場景, 並利用 Python 程式進行控制, 過程中必須將建構過程拍成帶有說明字幕的影片上傳至分組網頁. \n \n', 'tags': '', 'url': 'Exam.html'}, {'title': 'Exam1', 'text': '\n \n 作業檔案： exam1 \n 過程： 1.首先我們在做exam1前要先去solvespace內畫出我們除了起始角30度以外的角度，繪畫完後得到我們link1為30度、limk2為41.79度、link3為130.6度。 2.這三個角度轉為弳度為0.523599、0.729373、2.2794 3.這次作業使用HW1的檔案下去做修改 4.首先展開joint1裡面link1的rotation內的angle改為0.523599 5.再來是展開joint2裡面link2的rotation內的angle改為0.724137 6.最後展開joint3裡面link3的rotation內的angle改為2.2794 7.回到link2的children，再加入一個pose，展開裡面的translation XYZ改為0.3、0.2、0；pose內children加入shape 8.shape內的geometry加入box，將size XYZ改為0.1、0.3、0.1 9.最後儲存，開啟模擬成功 心得： 這次的exam1，使用先前HW1下去做更改，一開始一個一找要更改的部分，前後約使用1個小時，然後成功後再錄影，錄完約6分鐘，完整地做完後對於整體架構又更加理解。 \n \n Exam1 (10%): 建立 Webots 基本物件模擬場景 \n 操作影片標題: 國立虎尾科技大學 - 機械設計工程系 - cd2025 Exam1 - 學員學號', 'tags': '', 'url': 'Exam1.html'}, {'title': 'Exam2', 'text': '\n \n 考試檔案： slvs 、 webots \n 過程 1.首先先計算主動桿改為1.30m時，固定桿和從動桿為多少；最後得出固定桿3.25m、從動桿為1.95m和2.925m 2.依照這個尺寸在solvespace繪製線架構，並求出起始角以外的角度； 3.繪製完線架構後，開始繪製新的shape，並進行組裝 4.全部繪製、組裝完後，使用split_stl_to_obj_scale2.py這個程式去匯出obj 5.結束後打開webots開始設置，流程和HW2一樣，完成後開啟模擬檢查是否正確 心得 在這次的作業讓我深深體會到第一步錯就會導致後面就全錯，由於一開始的線架構我將原點設置在中間，並不是設置在最左邊，所以導致在設置joint4的jointparameters內的anchor無法設置正確，最後只好重新繪製線架構和組裝在繪出新的obj再做一次，得以完成。 \n \n Exam2 (10%): 利用 CAD 零組件建立模擬場景 \n 操作影片標題: 國立虎尾科技大學 - 機械設計工程系 - cd2025 Exam2 - 學員學號', 'tags': '', 'url': 'Exam2.html'}, {'title': 'Exam3', 'text': 'Exam3-1 \n \n Exam3-2 \n \n Exam3-3 \n \n \n 過程與心得 \n 1.首先先到 https://mde.tw/cd2025/content/IPv6.html 這個網頁找到自己的ipv6 \n 2.到電腦控制台、網際網路、乙太網路、內容ipv6做更改 \n 3.完成後打開cmd 打入 webot --stream\xa0 "檔案路徑\\檔名.wbt \n 4.正確打開webots後，打開瀏覽器到 http://localhost:1234/index.html \n 5.進入後先按connect，測試是否連上 \n 6.成功連上後將上面改成ws://[自己的ipv6]:1234 \n 7.成功連接上後，代表成功 \n 心得 \n 一開始看網頁上的敘述作業內容看的是一頭霧水，後來請教同學後才知道整個如何操作，這整個是透過 http://localhost:1234/index.html \xa0這個網頁來達到串流。 \n \n Exam3 (20%): Webots 機電模擬場景的協同設計 \n 操作影片標題: 國立虎尾科技大學 - 機械設計工程系 - cd2025 Exam3 - 學員學號 \n', 'tags': '', 'url': 'Exam3.html'}, {'title': 'Final', 'text': '\n 說明: \n PDf 報告檔案： Webots 動態投籃模擬系統的協同設計(第7組).pdf \n 作業檔案webots： final.7z \n  shooter youbots \n \n supervisor Robots \n \n stand youbots \n \n \n  transform \n \n \n counter supervisor \n \n \n final \n \n \n 期末協同專案執行過程影片、簡報與 PDf 報告檔案 (六人一組) (30%) \n 題目:\xa0 Webots 動態投籃模擬系統的協同設計 \n 籃框架被配置在一定範圍內, 可隨機慢速前進、後退及左右擺動, 投籃機構系統帶有一定數量的籃球, 被配置在可自由移動的輪車上. \n 操作者可利用鍵盤特定按鍵控制投籃輪車的移動並發射投籃, 每投出一球後系統透過記分板進行計分, 並由送球機構進行補球或移動輪車取球, 遊戲可進行至全部數量籃球投完為止. \n 請將期末協同專案執行過程、內容與心得, 製作成影片，配合字幕上傳至 Youtube 後嵌入各階段的期末報告頁面中. \n 影片標題:  國立虎尾科技大學 - 機械設計工程系 - cd2025 期末報告 - 學員學號 - 各階段影片主題', 'tags': '', 'url': 'Final.html'}, {'title': 'shooter youbots', 'text': '\n from controller import Robot, Keyboard  # 匯入 Webots 控制所需的 Robot 和 Keyboard 類別\n\n# 常數設定\nTIME_STEP = 32  # 控制循環的時間間隔（毫秒）\nMAX_VELOCITY = 10.0  # 車輪最大速度\nANGLE_STEP = 40 * 3.14159 / 180  # 將 40 度轉換為弧度（機構用角度）\nPOSITION_M = ANGLE_STEP          # 機構移動至 +40 度的位置\nPOSITION_K = 0.0                 # 機構移動至 0 度的位置\n\n# 初始化機器人與鍵盤\nrobot = Robot()  # 創建 Robot 物件\ntimestep = int(robot.getBasicTimeStep())  # 取得機器人基礎時間步長\nkeyboard = Keyboard()  # 創建鍵盤物件\nkeyboard.enable(timestep)  # 啟用鍵盤偵測，使用相同時間步長\n\n# 嘗試取得馬達與感測器裝置\ntry:\n    motor = robot.getDevice(\'motor1\')  # 取得名為 motor1 的馬達裝置\n    sensor = robot.getDevice(\'motor1_sensor\')  # 取得與馬達對應的感測器\n    sensor.enable(timestep)  # 啟用感測器以讀取資料\n    mechanism_enabled = True  # 成功取得裝置，啟用機構控制\nexcept Exception:\n    mechanism_enabled = False  # 若出錯（裝置不存在），則停用機構功能\n\n# 嘗試取得車輪裝置\ntry:\n    wheels = [robot.getDevice(f"wheel{i+1}") for i in range(4)]  # 取得四個車輪裝置\n    for wheel in wheels:\n        wheel.setPosition(float(\'inf\'))  # 設為無限位置，開啟速度控制模式\n        wheel.setVelocity(0)  # 初始速度設為 0\n    platform_enabled = True  # 若成功取得裝置，啟用平台控制\nexcept Exception:\n    platform_enabled = False  # 若取得失敗，停用平台功能\n\n# 狀態機初始狀態：允許按 F 鍵動作\ncurrent_state = "allow_f"\n\n# 記錄按鍵是否已被按下，用於去彈跳（避免重複觸發）\nkey_pressed = {\n    \'v\': False,  # 記錄 V 鍵是否被按下\n    \'f\': False   # 記錄 F 鍵是否被按下\n}\n\n# 主循環，重複執行直到模擬結束\nwhile robot.step(timestep) != -1:\n    key = keyboard.getKey()  # 讀取目前按下的鍵\n\n    # 平台控制（移動用輪子）\n    if platform_enabled:\n        if key == Keyboard.UP:\n            for wheel in wheels:\n                wheel.setVelocity(MAX_VELOCITY)  # 所有輪子向前\n        elif key == Keyboard.DOWN:\n            for wheel in wheels:\n                wheel.setVelocity(-MAX_VELOCITY)  # 所有輪子向後\n        elif key == Keyboard.LEFT:\n            # 左轉（左右輪反方向旋轉）\n            wheels[0].setVelocity(MAX_VELOCITY)\n            wheels[1].setVelocity(-MAX_VELOCITY)\n            wheels[2].setVelocity(MAX_VELOCITY)\n            wheels[3].setVelocity(-MAX_VELOCITY)\n        elif key == Keyboard.RIGHT:\n            # 右轉（左右輪反方向旋轉）\n            wheels[0].setVelocity(-MAX_VELOCITY)\n            wheels[1].setVelocity(MAX_VELOCITY)\n            wheels[2].setVelocity(-MAX_VELOCITY)\n            wheels[3].setVelocity(MAX_VELOCITY)\n        elif key == ord(\'Q\') or key == ord(\'q\'):\n            print("Exiting...")  # 按 Q 結束程式\n            break\n        else:\n            for wheel in wheels:\n                wheel.setVelocity(0)  # 沒有方向鍵按下時停止移動\n\n    # 馬達控制（用 F / V 鍵操作）\n    if mechanism_enabled:\n        _current_motor_position = sensor.getValue()  # 讀取馬達目前位置（可用於除錯）\n\n        # 按下 F 鍵時，若允許且尚未按住，讓馬達轉到 +40 度\n        if key == ord(\'F\') or key == ord(\'f\'):\n            if not key_pressed[\'f\'] and current_state == "allow_f":\n                motor.setPosition(POSITION_M)  # 馬達移動至 +40 度\n                current_state = "allow_v"  # 下一次只能按 V\n            key_pressed[\'f\'] = True  # 標記 F 鍵已按\n        else:\n            key_pressed[\'f\'] = False  # F 鍵已放開\n\n        # 按下 V 鍵時，若允許且尚未按住，讓馬達轉回 0 度\n        if key == ord(\'V\') or key == ord(\'v\'):\n            if not key_pressed[\'v\'] and current_state == "allow_v":\n                motor.setPosition(POSITION_K)  # 馬達移動至 0 度\n                current_state = "allow_f"  # 下一次只能按 F\n            key_pressed[\'v\'] = True  # 標記 V 鍵已按\n        else:\n            key_pressed[\'v\'] = False  # V 鍵已放開\n \n \n 在原本的城市當中是以M和K作為發射和回復，但我個人覺得有點不習慣，所以就改成了F和V', 'tags': '', 'url': 'shooter youbots.html'}, {'title': 'supervisor Robots', 'text': 'from controller import Supervisor, Keyboard  # 匯入 Webots 的 Supervisor 和鍵盤控制模組\nimport time                                   # 匯入時間模組，用於記錄與計時\nimport random                                 # 匯入隨機模組，用於顏色和命名\nimport numpy as np                            # 匯入 NumPy，用來處理向量運算\nimport re                                     # 匯入正規表達式模組，用來比對 DEF 名稱\n\n# ----------------- 參數區 -----------------\nHOOP_CENTER = [0.622, -0.103, 0.742838]       # 籃框中心座標\nBALL_DEF_PATTERN = re.compile(r"Sphere_\\d+")  # 比對球的 DEF 名稱用的正則表達式\n\nsupervisor = Supervisor()                     # 建立 Webots 的 Supervisor 實例\ntimestep = int(supervisor.getBasicTimeStep()) # 取得模擬時間步長\nkeyboard = Keyboard()                         # 建立鍵盤控制實例\nkeyboard.enable(timestep)                     # 啟用鍵盤，並設定更新頻率為 timestep\n\n# 球與軌跡點設定\nsphere_radius = 0.1\nTRAJECTORY_POINT_RADIUS = 0.03                # 軌跡球的半徑\nTRAJECTORY_POINT_STEP = 0.12                  # 軌跡點之間的最小距離\nTRAJECTORY_MAX_POINTS = 5                     # 最多顯示5個軌跡點\n\n# 狀態變數初始化\nwaiting_ball_def = None                       # 等待發射的球的 DEF 名稱\nwaiting_ball_info = None                      # 等待發射球的資訊（位置與顏色）\nlast_key_time = 0                             # 上一次按鍵時間（防止重複觸發）\ndebounce_time = 0.5                           # 按鍵去彈時間（秒）\ndefault_feed_pos = (-0.35, 0.0, 0.9)           # 新球產生時的相對位置\nPRINT_INTERVAL = 0.2                          # 球座標輸出間隔\n\ncurrent_tracked_def = None                    # 目前追蹤的球 DEF 名稱\nlast_print_time = time.time()                 # 上次輸出時間\n\ntrajectory_points = []                        # 保存目前的軌跡點 [(位置, def名稱)] 最多5個\n\n# ----------------- 函式定義 -----------------\n\n# 將軸角轉換為旋轉矩陣（用於從 local 座標轉為 world 座標）\ndef axis_angle_to_rotation_matrix(axis, angle):\n    x, y, z = axis\n    c = np.cos(angle)\n    s = np.sin(angle)\n    C = 1 - c\n    return np.array([\n        [x*x*C + c,   x*y*C - z*s, x*z*C + y*s],\n        [y*x*C + z*s, y*y*C + c,   y*z*C - x*s],\n        [z*x*C - y*s, z*y*C + x*s, z*z*C + c]\n    ])\n\n# 產生獨一無二的球名稱（根據時間戳與亂數）\ndef generate_valid_def_name(base_name="Sphere"):\n    timestamp = int(supervisor.getTime() * 1000)\n    return f"{base_name}_{timestamp}_{random.randint(0, 10000)}"\n\n# 產生隨機 RGB 顏色\ndef generate_random_color():\n    return random.random(), random.random(), random.random()\n\n# 將 youbot 上的 local 座標轉成 world 座標\ndef youbot_local_to_world(local_pos):\n    youbot_node = supervisor.getFromDef(\'youbot\')\n    if youbot_node is None:\n        raise RuntimeError("找不到 DEF 為 youbot 的 Robot 物件")\n    youbot_translation = np.array(youbot_node.getField(\'translation\').getSFVec3f())\n    youbot_rotation = youbot_node.getField(\'rotation\').getSFRotation()\n    youbot_axis = youbot_rotation[:3]\n    youbot_angle = youbot_rotation[3]\n    youbot_rot_mat = axis_angle_to_rotation_matrix(youbot_axis, youbot_angle)\n    rotated = youbot_rot_mat @ np.array(local_pos)\n    world_pos = youbot_translation + rotated\n    return tuple(world_pos)\n\n# 建立靜止球（不含物理）\ndef create_static_ball(def_name, world_pos, r, g, b):\n    sphere_string = f"""\n    DEF {def_name} Solid {{\n      translation {world_pos[0]} {world_pos[1]} {world_pos[2]}\n      contactMaterial "ball"\n      children [\n        Shape {{\n          geometry Sphere {{\n            radius {sphere_radius}\n          }}\n          appearance Appearance {{\n            material Material {{\n              diffuseColor {r} {g} {b}\n            }}\n          }}\n        }}\n      ]\n      boundingObject Sphere {{\n        radius {sphere_radius}\n      }}\n    }}\n    """\n    root = supervisor.getRoot()\n    children_field = root.getField("children")\n    children_field.importMFNodeFromString(-1, sphere_string)\n\n# 建立動態球（可以被物理模擬推動）\ndef create_dynamic_ball(def_name, world_pos, r, g, b):\n    sphere_string = f"""\n    DEF {def_name} Solid {{\n      translation {world_pos[0]} {world_pos[1]} {world_pos[2]}\n      contactMaterial "ball"\n      children [\n        Shape {{\n          geometry Sphere {{\n            radius {sphere_radius}\n          }}\n          appearance Appearance {{\n            material Material {{\n              diffuseColor {r} {g} {b}\n            }}\n          }}\n        }}\n      ]\n      boundingObject Sphere {{\n        radius {sphere_radius}\n      }}\n      physics Physics {{\n        mass 0.01\n        density -1\n      }}\n    }}\n    """\n    root = supervisor.getRoot()\n    children_field = root.getField("children")\n    children_field.importMFNodeFromString(-1, sphere_string)\n\n# 建立軌跡小球作為可視化記號（Transform + Shape，無物理）\ndef create_trajectory_point(pos):\n    def_name = generate_valid_def_name("TrajectoryPt")\n    sphere_string = f"""\n    DEF {def_name} Transform {{\n      translation {pos[0]} {pos[1]} {pos[2]}\n      children [\n        Shape {{\n          geometry Sphere {{\n            radius {TRAJECTORY_POINT_RADIUS}\n          }}\n          appearance Appearance {{\n            material Material {{\n              diffuseColor 1 0.7 0\n              transparency 0.3\n            }}\n          }}\n        }}\n      ]\n    }}\n    """\n    root = supervisor.getRoot()\n    children_field = root.getField("children")\n    children_field.importMFNodeFromString(-1, sphere_string)\n    return def_name\n\n# 刪除目前所有軌跡點\ndef delete_trajectory_points():\n    global trajectory_points\n    for _, def_name in trajectory_points:\n        node = supervisor.getFromDef(def_name)\n        if node:\n            node.remove()\n    trajectory_points.clear()\n\n# 建立一顆靜止球（並儲存它的資訊）\ndef create_static_sphere(supervisor, x, y, z):\n    global waiting_ball_def, waiting_ball_info\n    def_name = generate_valid_def_name()\n    waiting_ball_def = def_name\n    r, g, b = generate_random_color()\n    world_pos = youbot_local_to_world((x, y, z))\n    waiting_ball_info = (world_pos, r, g, b)\n    create_static_ball(def_name, world_pos, r, g, b)\n\n# 將靜止球移除並改為物理球\ndef activate_dynamic_ball():\n    global waiting_ball_def, waiting_ball_info\n    if waiting_ball_def is None or waiting_ball_info is None:\n        return\n    ball_node = supervisor.getFromDef(waiting_ball_def)\n    if ball_node is not None:\n        ball_node.remove()\n        supervisor.step(int(supervisor.getBasicTimeStep()))\n    world_pos, r, g, b = waiting_ball_info\n    create_dynamic_ball(waiting_ball_def, world_pos, r, g, b)\n    waiting_ball_def = None\n    waiting_ball_info = None\n\n# 判斷球是否落地（以 z 軸高度為依據）\ndef is_ball_landed(pos, threshold_z=0.13):\n    return pos[2] < threshold_z\n\n# ----------------- 主迴圈 -----------------\n\nprint("按 R 產生一顆靜止球，按 F 讓球變 dynamic 可擊出（最多只有5個軌跡點跟著球跑，球落地後軌跡自動消失）")\n\nwhile supervisor.step(timestep) != -1:\n    key = keyboard.getKey()\n    current_time = time.time()\n\n    # 按 R 鍵產生一顆靜止球\n    if key == ord(\'R\') and (current_time - last_key_time >= debounce_time):\n        if waiting_ball_def is None:\n            create_static_sphere(supervisor, *default_feed_pos)\n            current_tracked_def = waiting_ball_def\n            delete_trajectory_points()\n        else:\n            print("還有一顆球等待擊出，請先擊出再產生新球。")\n        last_key_time = current_time\n\n    # 按 F 鍵讓球變成可被物理推動（Dynamic）\n    if key == ord(\'F\') and (current_time - last_key_time >= debounce_time):\n        activate_dynamic_ball()\n        last_key_time = current_time\n\n    # 若目前有追蹤的球，就更新軌跡顯示與落地檢查\n    if current_tracked_def is not None:\n        ball_node = supervisor.getFromDef(current_tracked_def)\n        if ball_node is not None:\n            pos = ball_node.getPosition()\n            if current_time - last_print_time >= PRINT_INTERVAL:\n                # print(f"球 {current_tracked_def} 絕對座標: [{pos[0]:.4f}, {pos[1]:.4f}, {pos[2]:.4f}]")\n                last_print_time = current_time\n\n            # 若與上一個軌跡點距離足夠遠，新增新的軌跡點\n            if (not trajectory_points) or np.linalg.norm(np.array(pos) - np.array(trajectory_points[-1][0])) > TRAJECTORY_POINT_STEP:\n                def_name = create_trajectory_point(pos)\n                trajectory_points.append((pos, def_name))\n                if len(trajectory_points) > TRAJECTORY_MAX_POINTS:\n                    _, old_def = trajectory_points.pop(0)\n                    node = supervisor.getFromDef(old_def)\n                    if node:\n                        node.remove()\n\n            # 若球落地，刪除軌跡\n            if is_ball_landed(pos):\n                delete_trajectory_points()\n        else:\n            delete_trajectory_points()\n            current_tracked_def = None\n \n \n 在這程式當中我將原本的A鍵給球變成R鍵給球，然後還有先前的shooter youbots的發射鍵改成F，所以在這邊的M也需要改成F，以免在原本執行上出問題。', 'tags': '', 'url': 'supervisor Robots.html'}, {'title': 'stand youbots', 'text': '\n from controller import Robot, Keyboard  # 匯入 Webots 提供的 Robot 與 Keyboard 類別\n\n# 常數定義\nWHEEL_RADIUS = 0.1  # 輪子的半徑（單位：公尺），此處為 10 公分\nL = 0.471  # 機器人長度的一半（用於動力學計算）\nW = 0.376  # 機器人寬度的一半\nMAX_VELOCITY = 10.0  # 輪子的最大速度（單位：rad/s）\n\n# 初始化機器人實體\nrobot = Robot()\n\n# 取得模擬的時間步長（time step）\ntimestep = int(robot.getBasicTimeStep())\n\n# 取得發射器裝置，用於傳送分數（與其他模組或裝置通訊）\nemitter = robot.getDevice("score_emitter")\n\nscore_to_send = 2  # 每次感測成功後加分數，這裡設為 2 分，可自行調整\n\n# 初始化距離感測器（距離球進入感測區的偵測裝置）\nsensor = robot.getDevice(\'sensor\')  # 取得感測器裝置\nsensor.enable(timestep)  # 啟用感測器並設定刷新速率\n\nscore = 0  # 初始分數\nlast_score_time = 0  # 上一次得分的時間\ncooldown = 1.0  # 冷卻時間（秒），防止重複計分\n\n# 初始化鍵盤控制器\nkeyboard = Keyboard()\nkeyboard.enable(timestep)  # 啟用鍵盤偵測並設定刷新速率\n\n# 取得四個馬達裝置（四輪全驅）\nwheel5 = robot.getDevice("wheel5")  # 前右輪\nwheel6 = robot.getDevice("wheel6")  # 前左輪\nwheel7 = robot.getDevice("wheel7")  # 後右輪\nwheel8 = robot.getDevice("wheel8")  # 後左輪\n\n# 設定輪子為速度控制模式（inf 表示不限制旋轉角度）\nfor wheel in [wheel5, wheel6, wheel7, wheel8]:\n    wheel.setPosition(float(\'inf\'))  # 設定為速度控制（非位置控制）\n    wheel.setVelocity(0)  # 初始速度為 0（靜止）\n\n# 定義控制四個輪子速度的函式\ndef set_wheel_velocity(v1, v2, v3, v4):\n    """設定每個輪子的速度"""\n    wheel5.setVelocity(v1)\n    wheel6.setVelocity(v2)\n    wheel7.setVelocity(v3)\n    wheel8.setVelocity(v4)\n\n# 將感測器AD值對應到距離的查表函式（線性插值）\nlookup_table = [\n    (1000, 0.00),\n    (620, 0.12),\n    (372, 0.13),\n    (248, 0.14),\n    (186, 0.15),\n    (0, 0.18)\n]\n\n# 根據感測器的AD值推算實際距離（單位：公尺）\ndef ad_to_distance(ad_value):\n    # AD 值遞減時表示距離遞增（感測器邏輯）\n    for i in range(len(lookup_table)-1):\n        a0, d0 = lookup_table[i]\n        a1, d1 = lookup_table[i+1]\n        if a1 <= ad_value <= a0:\n            # 線性插值公式：在 a0 和 a1 之間計算距離值\n            return d0 + (d1 - d0) * (ad_value - a0) / (a1 - a0)\n    # 若超出表格範圍則回傳邊界值\n    if ad_value > lookup_table[0][0]:\n        return lookup_table[0][1]\n    return lookup_table[-1][1]\n\n# 主迴圈開始，負責持續讀取感測器與鍵盤輸入\nprint("Use \'W\', \'S\', \'A\', \'D\' keys to control the robot.")\nprint("W: Move forward, S: Move backward, A: Turn left, D: Turn right.")\nprint("Press \'Q\' to quit.")\n\nwhile robot.step(timestep) != -1:  # 每次時間步進（直到模擬結束）\n\n    key = keyboard.getKey()  # 讀取目前按下的鍵\n\n    # 讀取距離感測器數值\n    sensor_value = sensor.getValue()\n    distance = ad_to_distance(sensor_value)  # 轉換成距離（公尺）\n\n    current_time = robot.getTime()  # 取得當前模擬時間\n\n    # 如果按下 F 鍵，印出目前距離（除錯用）\n    if key == ord(\'F\') or key == ord(\'f\'):\n        print(distance)\n\n    # 如果按下 V 鍵，也印出距離（除錯用）\n    if key == ord(\'V\') or key == ord(\'v\'):\n        print(distance)\n\n    # 若感測距離小於 0.11 公尺，且超過冷卻時間，則加分\n    if distance < 0.11 and (current_time - last_score_time) > cooldown:\n        score += 2\n        print("得分")  # 顯示得分訊息\n        print(distance)  # 顯示當前距離\n        emitter.send(str(score_to_send).encode(\'utf-8\'))  # 傳送分數給外部（如顯示器）\n\n        last_score_time = current_time  # 更新上次得分時間\n\n    # 根據按鍵控制輪子移動方向\n    if key == ord(\'S\') or key == ord(\'w\'):\n        # 前進\n        velocity = MAX_VELOCITY\n        set_wheel_velocity(velocity, velocity, velocity, velocity)\n    elif key == ord(\'W\') or key == ord(\'s\'):\n        # 後退\n        velocity = -MAX_VELOCITY\n        set_wheel_velocity(velocity, velocity, velocity, velocity)\n    elif key == ord(\'D\') or key == ord(\'d\'):\n        # 右轉：左輪前進，右輪後退\n        velocity = MAX_VELOCITY\n        set_wheel_velocity(-velocity, velocity, -velocity, velocity)\n    elif key == ord(\'A\') or key == ord(\'a\'):\n        # 左轉：左輪後退，右輪前進\n        velocity = MAX_VELOCITY\n        set_wheel_velocity(velocity, -velocity, velocity, -velocity)\n    elif key == ord(\'Q\') or key == ord(\'q\'):\n        # 離開程式\n        print("Exiting...")\n        break\n    else:\n        # 沒有按鍵時停止移動\n        set_wheel_velocity(0, 0, 0, 0)\n \n \n 我將原本控制第二台車的按鍵EDSX 改成遊戲常用的WDAS，這樣是能讓移動上更加直覺。', 'tags': '', 'url': 'stand youbots.html'}, {'title': 'counter supervisor', 'text': '\n from controller import Supervisor\n\n# 七段顯示器每個數字對應的亮燈狀態（a-g段）\nSEGMENTS = [\n    [1,1,1,1,1,1,0], # 0\n    [0,1,1,0,0,0,0], # 1\n    [1,1,0,1,1,0,1], # 2\n    [1,1,1,1,0,0,1], # 3\n    [0,1,1,0,0,1,1], # 4\n    [1,0,1,1,0,1,1], # 5\n    [1,0,1,1,1,1,1], # 6\n    [1,1,1,0,0,0,0], # 7\n    [1,1,1,1,1,1,1], # 8\n    [1,1,1,1,0,1,1], # 9\n]\n\n# 各個數字位數（百、十、個）對應的材質名稱（a-g 段）\nDIGIT_MATERIALS = [\n    [\'a3mat\', \'b3mat\', \'c3mat\', \'d3mat\', \'e3mat\', \'f3mat\', \'g3mat\'], # 百位\n    [\'a2mat\', \'b2mat\', \'c2mat\', \'d2mat\', \'e2mat\', \'f2mat\', \'g2mat\'], # 十位\n    [\'a1mat\', \'b1mat\', \'c1mat\', \'d1mat\', \'e1mat\', \'f1mat\', \'g1mat\'], # 個位\n]\n\n# 定義亮燈的顏色 (綠色)\nON_COLOR = [0, 1, 0]\n\n# 定義熄燈的顏色 (深灰)\nOFF_COLOR = [0.05, 0.05, 0.05]\n\n# 設定某一個位數的顯示數字\ndef set_digit(supervisor, digit_index, value):\n    segs = SEGMENTS[value]  # 取得該數字對應的七段顯示狀態\n    for i, seg_on in enumerate(segs):\n        # 根據 digit_index 取得該段的材質節點\n        mat_node = supervisor.getFromDef(DIGIT_MATERIALS[digit_index][i])\n        if mat_node:\n            # 設定段的顏色：亮或暗\n            mat_node.getField(\'diffuseColor\').setSFColor(ON_COLOR if seg_on else OFF_COLOR)\n        else:\n            print(f"找不到 {DIGIT_MATERIALS[digit_index][i]} 這個DEF")  # 找不到對應 DEF 時輸出錯誤\n\n# 設定整個顯示器顯示的數字（最多 3 位數）\ndef set_display(supervisor, value):\n    value = max(0, min(999, int(value)))  # 限制數值在 0~999 範圍\n    h = value // 100                     # 百位\n    t = (value // 10) % 10               # 十位\n    u = value % 10                       # 個位\n    set_digit(supervisor, 0, h)          # 設定百位數字\n    set_digit(supervisor, 1, t)          # 設定十位數字\n    set_digit(supervisor, 2, u)          # 設定個位數字\n\n# 建立 Supervisor 實例\nsupervisor = Supervisor()\n\n# 取得 Webots 中設定的基本時間步長\ntimestep = int(supervisor.getBasicTimeStep())\n\n# 初始分數為 0\nscore = 0\n\n# 取得名為 "score_receiver" 的裝置（接收分數訊息）\nreceiver = supervisor.getDevice("score_receiver")\nreceiver.enable(timestep)  # 啟用接收器，並以 timestep 為更新間隔\n\n# 主迴圈，每個時間步執行一次\nwhile supervisor.step(timestep) != -1:\n    # 當接收器中有資料時\n    while receiver.getQueueLength() > 0:\n        data = receiver.getString()  # 取得接收到的字串資料\n        if data.isdigit():           # 檢查是否是數字字串\n            try:\n                received_score = int(data)  # 將字串轉成整數\n                score += received_score     # 累加到總分\n                print(f"收到得分訊息: +{received_score}, 總分: {score}")  # 印出訊息\n            except Exception as e:\n                print("訊息格式錯誤:", e)  # 如果轉換錯誤，顯示錯誤訊息\n        receiver.nextPacket()  # 移至下一筆封包\n    set_display(supervisor, score)  # 更新七段顯示器的分數顯示\n \n \n', 'tags': '', 'url': 'counter supervisor.html'}, {'title': 'Brython', 'text': '1 add to 100 \n  導入 brython 程式庫  \n \n \n \n \n  啟動 Brython  \n \n \n \n  導入 FileSaver 與 filereader  \n \n \n \n \n  導入 ace  \n \n \n \n \n \n \n  導入 gearUtils-0.9.js Cango 齒輪繪圖程式庫  \n \n \n \n \n \n \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src1"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n \n \n \n  add 1 to 100 開始  \n \n \n  add 1 to 100 結束 \n  editor1 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n Filename:  .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n Run   Output   清除輸出區 清除繪圖區 Reload \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor1 結束   ##########################################  \n 從 1 累加到 100 part2: \n 1 add to 100 cango_three_gears BSnake AI Tetris \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src2"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n  add 1 to 100 part2 開始  \n \n \n  add 1 to 100 part2 結束 \n  editor2 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n Filename:  .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n Run   Output   清除輸出區 清除繪圖區 Reload \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor2 結束  \n \n \n', 'tags': '', 'url': 'Brython.html'}]};